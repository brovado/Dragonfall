<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dragonfall Preview</title>

    <!-- Tailwind (for your current UI classes) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React (UMD builds) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel so we can run JSX in-browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>

  <body class="bg-zinc-950">
    <div id="root"></div>

    <script type="text/babel">
const { useEffect, useMemo, useRef, useState } = React;

/**
 * DRAGONFALL: MOUNTAIN EXILE — v0.3
 * Upgrades in this iteration:
 * - Version bump visible on title/header
 * - TRUE MAP travel: named locations + adjacency (not “node web”)
 * - Enemies scale by area level
 * - Safe locations (and built beacons) have NO monsters (rest is safe there)
 * - Early game flow: Weapon -> Style -> travel/fights -> XP gate -> Promotion (Element OR Cross)
 * - Loot now has meaning & value; extracted loot can be sold for gold
 */

const VERSION = "0.3.0";
const SAVE_KEY = "dragonfall_save_v03";

function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
function uid() { return Math.random().toString(16).slice(2) + Date.now().toString(16); }

// Deterministic RNG (mulberry32)
function mulberry32(seed) {
  let a = seed >>> 0;
  return function () {
    a |= 0; a = (a + 0x6d2b79f5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function rollDie(rng, sides) { return 1 + Math.floor(rng() * sides); }
function fmtBonus(b) { if (b === 0) return "+0"; return b > 0 ? `+${b}` : `${b}`; }

const DR = { easy: 10, standard: 13, hard: 16, extreme: 19 };

// --- Builds -----------------------------------------------------------------

const WEAPONS = [
  {
    key: "sword",
    name: "Sword",
    tagline: "Close combat • control • endurance",
    bias: { might: 1, finesse: 1, wits: 0, will: 0 },
    styles: [
      { key: "guard", name: "Guard", desc: "Defense, counters, zone control." },
      { key: "edge", name: "Edge", desc: "Precision, crits, bleed." },
      { key: "fury", name: "Fury", desc: "Momentum, risk, finishing." },
    ],
  },
  {
    key: "bow",
    name: "Bow",
    tagline: "Range • positioning • tempo",
    bias: { might: 0, finesse: 2, wits: 1, will: 0 },
    styles: [
      { key: "sniper", name: "Sniper", desc: "Single-target lethality." },
      { key: "skirmisher", name: "Skirmisher", desc: "Mobility, rapid shots." },
      { key: "trapper", name: "Trapper", desc: "Terrain control, prep." },
    ],
  },
  {
    key: "wand",
    name: "Wand",
    tagline: "Channeling • volatility • rituals",
    bias: { might: 0, finesse: 0, wits: 1, will: 2 },
    styles: [
      { key: "invoker", name: "Invoker", desc: "Raw spellcasting." },
      { key: "binder", name: "Binder", desc: "Debuffs, wards, control." },
      { key: "channeler", name: "Channeler", desc: "Sustained power, scaling." },
    ],
  },
];

const ELEMENTS = [
  { key: "fire", name: "Fire", vibe: "Escalation • burning risk" },
  { key: "ice", name: "Ice", vibe: "Control • delay • precision" },
  { key: "storm", name: "Storm", vibe: "Speed • chaining chaos" },
  { key: "earth", name: "Earth", vibe: "Endurance • retaliation" },
  { key: "void", name: "Void", vibe: "Sacrifice • inversion" },
];

// --- Loot (meaning + value) -------------------------------------------------
// Items are objects: { id, key, name, value, tags[], desc }
const LOOT = [
  { key: "iron_shards", name: "Iron Shards", value: 3, tags: ["metal","common"], desc: "Good for bracing plates and crude repairs." },
  { key: "salt_rope", name: "Salt Rope", value: 4, tags: ["utility","common"], desc: "Cures meat, binds wounds, binds deals." },
  { key: "old_sigil", name: "Old Sigil", value: 6, tags: ["arcane","uncommon"], desc: "A stamped charm. Warm when lies are spoken." },

  { key: "relay_parts", name: "Relay Parts", value: 8, tags: ["beacon","uncommon"], desc: "Spare coils and crystal housings from the old beacons." },
  { key: "beacon_ink", name: "Beacon Ink", value: 5, tags: ["arcane","common"], desc: "Black-blue. Refuses to dry in sunlight." },
  { key: "ration_bar", name: "Ration Bar", value: 2, tags: ["food","common"], desc: "Dense. Bitter. Effective." },

  { key: "scaled_fragment", name: "Scaled Fragment", value: 7, tags: ["wyrm","uncommon"], desc: "A scale sliver. Hard as sin." },
  { key: "charcoal_resin", name: "Charcoal Resin", value: 6, tags: ["alchemy","uncommon"], desc: "Burns slow. Clings to steel." },
  { key: "bright_glass", name: "Bright Glass", value: 9, tags: ["rare","arcane"], desc: "A shard that catches moonlight even at noon." },

  { key: "ember_fang", name: "Ember Fang", value: 12, tags: ["trophy","wyrm","rare"], desc: "A trophy that buys respect—or trouble." },
  { key: "ward_coil", name: "Ward Coil", value: 10, tags: ["beacon","rare"], desc: "A humming coil that stabilizes hostile air." },
  { key: "void_chit", name: "Void Chit", value: 14, tags: ["void","rare"], desc: "A coin that feels heavier than it should." },
];

function mkLootItem(baseKey, seed) {
  const base = LOOT.find(x => x.key === baseKey) || LOOT[0];
  return { id: uid(), ...base, seed };
}

function sumLootValue(items) {
  return (items || []).reduce((a, it) => a + (it?.value || 0), 0);
}

// --- Map (named locations + adjacency) --------------------------------------
// kind: "safe" | "danger" | "station" | "event"
const MAP_LOCATIONS = [
  {
    id: "beacon_gate",
    name: "Beacon Gate",
    kind: "safe",
    level: 0,
    region: "Ember March",
    tone: "A basalt arch lit by ward-light. Survivors barter in whispers beneath the hum.",
    lootTable: ["ration_bar","beacon_ink"],
    coords: { x: 10, y: 55 },
    links: ["ashway_bridge","ruined_relay"]
  },
  {
    id: "ashway_bridge",
    name: "Ashway Bridge",
    kind: "danger",
    level: 1,
    region: "Ember March",
    tone: "Black water churns beneath a cracked span. Wind howls through broken stone ribs.",
    lootTable: ["iron_shards","salt_rope","old_sigil"],
    coords: { x: 28, y: 35 },
    links: ["beacon_gate","ruined_relay","wyrm_path"]
  },
  {
    id: "ruined_relay",
    name: "Ruined Beacon Relay",
    kind: "station",
    level: 1,
    region: "Ember March",
    tone: "A collapsed outpost with a dormant crystal core. Someone died here recently.",
    lootTable: ["relay_parts","beacon_ink","ration_bar"],
    coords: { x: 30, y: 75 },
    links: ["beacon_gate","ashway_bridge","wyrm_path","cinder_watch"]
  },
  {
    id: "wyrm_path",
    name: "Wyrm Path",
    kind: "danger",
    level: 2,
    region: "Ember March",
    tone: "Claw marks score the rock. Heat breathes from the cracks like a sleeping furnace.",
    lootTable: ["scaled_fragment","charcoal_resin","bright_glass"],
    coords: { x: 52, y: 55 },
    links: ["ashway_bridge","ruined_relay","cinder_watch","shardfall_slope"]
  },
  {
    id: "cinder_watch",
    name: "Cinderwatch Overlook",
    kind: "event",
    level: 2,
    region: "Ember March",
    tone: "A lookout tower snapped in half. The horizon is a bruise—purple, blue, and smoke.",
    lootTable: ["old_sigil","bright_glass","ward_coil"],
    coords: { x: 52, y: 20 },
    links: ["ruined_relay","wyrm_path"]
  },
  {
    id: "shardfall_slope",
    name: "Shardfall Slope",
    kind: "danger",
    level: 3,
    region: "Upper Scree",
    tone: "A slope of glassy rock. Every step threatens a singing collapse.",
    lootTable: ["bright_glass","ember_fang","void_chit"],
    coords: { x: 76, y: 55 },
    links: ["wyrm_path"]
  },
];

// --- Enemies (scaled by area level) -----------------------------------------
// (kept simple: each tier has a pool; we pick based on location.level)
const ENEMY_POOLS = {
  1: [
    { key: "wyrmling", name: "Wyrmling Scout", hp: 8, dr: 12, attackDR: 12, dmg: [1, 3],
      desc: "A juvenile dragonkin with a barbed spear and too much confidence." },
    { key: "ashwolf", name: "Ash-Wolf", hp: 10, dr: 13, attackDR: 12, dmg: [2, 4],
      desc: "Grey fur dusted in ember. It circles like a hungry thought." },
  ],
  2: [
    { key: "cultist", name: "Scalebound Cultist", hp: 12, dr: 13, attackDR: 13, dmg: [2, 5],
      desc: "Eyes like candles. The air around them tastes of coin and smoke." },
    { key: "mire_drake", name: "Mire-Drake Strider", hp: 13, dr: 14, attackDR: 13, dmg: [2, 6],
      desc: "A low-slung drake that moves like a crack in the ground." },
  ],
  3: [
    { key: "ember_knight", name: "Ember Knight Remnant", hp: 16, dr: 15, attackDR: 14, dmg: [3, 7],
      desc: "Armor fused to bone. It remembers an oath and hates you for breathing." },
    { key: "voidling", name: "Voidling", hp: 15, dr: 15, attackDR: 15, dmg: [3, 8],
      desc: "A shadow with teeth—more absence than body." },
  ],
};

function pickEnemyForLevel(rng, lvl) {
  const tier = clamp(lvl, 1, 3);
  const pool = ENEMY_POOLS[tier] || ENEMY_POOLS[1];
  return pool[Math.floor(rng() * pool.length)];
}

// --- Stats / Titles ----------------------------------------------------------

function computeStats(base, weaponBias, styleKey, elementKey, crossKey) {
  const s = { ...base };
  for (const k of Object.keys(weaponBias)) s[k] += weaponBias[k];

  if (styleKey) {
    const map = {
      guard: { might: 1 }, edge: { finesse: 1 }, fury: { might: 1 },
      sniper: { finesse: 1, wits: 1 }, skirmisher: { finesse: 1 }, trapper: { wits: 2 },
      invoker: { wits: 1, will: 1 }, binder: { wits: 1, will: 1 }, channeler: { will: 2 },
    };
    const add = map[styleKey] || {};
    for (const k of Object.keys(add)) s[k] = (s[k] || 0) + add[k];
  }

  if (elementKey) {
    const map = {
      fire: { might: 1 }, ice: { finesse: 1 }, storm: { will: 1 }, earth: { might: 1 }, void: { will: 1 },
    };
    const add = map[elementKey] || {};
    for (const k of Object.keys(add)) s[k] = (s[k] || 0) + add[k];
  }

  // Cross-training = flexibility, less raw
  if (crossKey) { s.wits += 1; s.finesse += 1; s.might -= 1; }

  s.might = clamp(s.might || 0, -1, 6);
  s.finesse = clamp(s.finesse || 0, -1, 6);
  s.wits = clamp(s.wits || 0, -1, 6);
  s.will = clamp(s.will || 0, -1, 6);
  return s;
}

function titleFromBuild(weaponKey, styleKey, elementKey, crossStyle) {
  const weapon = WEAPONS.find((w) => w.key === weaponKey)?.name || "";
  const style = WEAPONS.flatMap((w) => w.styles).find((s) => s.key === styleKey)?.name || "";
  const el = ELEMENTS.find((e) => e.key === elementKey)?.name || "";

  if (!weaponKey) return "Unbound";
  if (!styleKey) return weapon;

  if (crossStyle) {
    const crossName = WEAPONS.flatMap((w) => w.styles).find((s) => s.key === crossStyle)?.name || "Cross";
    return `${weapon} ${style} • ${crossName}`;
  }

  if (elementKey) {
    const base = `${el}${weapon}`;
    const suffixMap = {
      Guard: "Sentinel", Edge: "Duelist", Fury: "Reaver",
      Sniper: "Marksman", Skirmisher: "Rover", Trapper: "Warden",
      Invoker: "Invoker", Binder: "Binder", Channeler: "Channeler",
    };
    return `${base} ${suffixMap[style] || "Adept"}`;
  }

  return `${weapon} ${style}`;
}

function rollCheck(rng, label, statBonus, dr) {
  const d20 = rollDie(rng, 20);
  const total = d20 + statBonus;
  return { label, d20, statBonus, total, dr, success: total >= dr };
}
function rollDamage(rng, min, max) { return min + Math.floor(rng() * (max - min + 1)); }

function computeAttackMod(stats, weaponKey) {
  if (weaponKey === "sword") return stats.might + Math.floor(stats.finesse / 2);
  if (weaponKey === "bow") return stats.finesse + Math.floor(stats.wits / 2);
  if (weaponKey === "wand") return stats.will + Math.floor(stats.wits / 2);
  return 0;
}
function computeDefenseMod(stats, styleKey) {
  let mod = Math.floor((stats.might + stats.will) / 2);
  if (styleKey === "guard") mod += 1;
  if (styleKey === "trapper") mod += 1;
  if (styleKey === "binder") mod += 1;
  return mod;
}

function skillListForBuild(weaponKey, styleKey, elementKey, crossStyle) {
  const base = [];
  const attackLabel = weaponKey === "bow" ? "Shoot" : weaponKey === "wand" ? "Cast" : "Strike";
  base.push({ key: "attack", name: attackLabel, kind: "action", desc: "Roll to hit. On success, deal damage." });
  base.push({ key: "defend", name: "Brace", kind: "action", desc: "Raise defense this round. Reduce damage on hit." });
  base.push({ key: "maneuver", name: "Maneuver", kind: "action", desc: "Reposition to set up advantage." });

  const specials = {
    guard: { key: "riposte", name: "Shield-Check", desc: "A controlled shove. Safe, reliable." },
    edge: { key: "bleed", name: "Open Vein", desc: "Higher damage; risk a bite-back." },
    fury: { key: "lunge", name: "Lunge", desc: "Big swing; missing hurts." },
    sniper: { key: "aim", name: "Aim", desc: "Take a breath; next shot hits harder." },
    skirmisher: { key: "dash", name: "Dash Shot", desc: "Attack and slip away on success." },
    trapper: { key: "snare", name: "Snare", desc: "Hinder the next enemy attack." },
    invoker: { key: "bolt", name: "Arc Bolt", desc: "High variance magic strike." },
    binder: { key: "hex", name: "Hex", desc: "Weaken defenses, then hit." },
    channeler: { key: "focus", name: "Focus", desc: "Charge power; next roll +2." },
  };
  if (styleKey && specials[styleKey]) base.push({ ...specials[styleKey], kind: "action" });

  const elementPassives = {
    fire: "Fire: crits scorch (+1).",
    ice: "Ice: maneuvers slow (enemy −1 next roll).",
    storm: "Storm: once per scene, reroll a d20.",
    earth: "Earth: Brace reduces +1 extra damage.",
    void: "Void: when low HP, +1 to Will rolls.",
  };
  if (elementKey) base.push({ key: `passive_${elementKey}`, name: "Affinity", kind: "passive", desc: elementPassives[elementKey] });

  if (crossStyle) {
    const crossName = WEAPONS.flatMap((w) => w.styles).find((s) => s.key === crossStyle)?.name || "Cross";
    base.push({ key: "cross", name: "Cross-Training", kind: "passive", desc: `You carry a slice of ${crossName}.` });
  }
  return base;
}

// --- Game State --------------------------------------------------------------

function mkNewGame(seed = Date.now()) {
  const gameId = uid();
  const rngSeed = (seed ^ gameId.length) >>> 0;

  return {
    version: VERSION,
    gameId,
    rngSeed,
    phase: "start", // start | chooseStyle | play | dead
    book: { chapter: 1, page: 1 },
    meta: { echoes: 0, legacy: { startHP: 0, revealHints: 0 } },

    player: {
      name: "",
      weapon: null,
      style: null,
      element: null,
      crossStyle: null,
      baseStats: { might: 0, finesse: 0, wits: 0, will: 0 },
      stats: { might: 0, finesse: 0, wits: 0, will: 0 },
      hpMax: 10,
      hp: 10,
      gold: 0,
      xp: 0,
      promoTier: 0,   // 0=weapon+style only, 1=affinity/cross unlocked
      nextPromoAt: 4, // keep your original gating; fights give 2 XP → “a lil xp” before promo
      inventory: [],  // carried loot items (objects)
      extracted: [],  // extracted loot items (objects)
      stationBuiltAt: {}, // { locationId: true }
      title: "Unbound",
    },

    run: {
      depth: 0,
      region: "Ember March",
      currentLocationId: "beacon_gate",
      discovered: { beacon_gate: true }, // fog-of-war lite
      cleared: {}, // { locationId: true } for danger places
      inCombat: false,
      enemy: null,
      enemyHP: 0,
      log: [],
    },

    ui: {
      showClassTree: true,
      showPromotion: false,
      showClassReveal: false,
      classRevealText: "",
    },
  };
}

function pushLog(state, entry) {
  const line = { id: uid(), t: Date.now(), ...entry };
  state.run.log = [line, ...state.run.log].slice(0, 160);
}

// --- UI components -----------------------------------------------------------

function Card({ title, subtitle, children, right }) {
  return (
    <div className="rounded-2xl bg-white/5 border border-white/10 shadow-[0_10px_30px_rgba(0,0,0,0.35)]">
      <div className="px-4 py-3 border-b border-white/10 flex items-start justify-between gap-3">
        <div>
          <div className="text-lg font-semibold tracking-tight">{title}</div>
          {subtitle ? <div className="text-sm text-white/70 mt-0.5">{subtitle}</div> : null}
        </div>
        {right ? <div className="shrink-0">{right}</div> : null}
      </div>
      <div className="p-4">{children}</div>
    </div>
  );
}
function Pill({ children }) {
  return (
    <span className="inline-flex items-center gap-1 rounded-full px-2 py-1 text-xs bg-white/10 border border-white/10">
      {children}
    </span>
  );
}
function Button({ children, onClick, variant = "primary", disabled, title }) {
  const base = "rounded-xl px-3 py-2 text-sm font-medium border transition active:scale-[0.99]";
  const styles = {
    primary: "bg-white text-black border-white/20 hover:bg-white/90 disabled:opacity-50",
    ghost: "bg-white/5 text-white border-white/10 hover:bg-white/10 disabled:opacity-50",
    danger: "bg-red-500/15 text-red-200 border-red-500/30 hover:bg-red-500/20 disabled:opacity-50",
  };
  return (
    <button className={`${base} ${styles[variant]}`} onClick={onClick} disabled={disabled} title={title}>
      {children}
    </button>
  );
}
function Divider() { return <div className="h-px bg-white/10 my-3" />; }

function kindBadge(kind, beaconHere) {
  if (beaconHere) return { label: "SAFE • BEACON", cls: "bg-emerald-500/15 text-emerald-200 border-emerald-500/30" };
  if (kind === "safe") return { label: "SAFE", cls: "bg-emerald-500/15 text-emerald-200 border-emerald-500/30" };
  if (kind === "station") return { label: "RELAY", cls: "bg-sky-500/15 text-sky-200 border-sky-500/30" };
  if (kind === "event") return { label: "EVENT", cls: "bg-indigo-500/15 text-indigo-200 border-indigo-500/30" };
  return { label: "DANGER", cls: "bg-red-500/15 text-red-200 border-red-500/30" };
}

// --- Main -------------------------------------------------------------------

function DragonfallMountainExilePreview() {
  const [state, setState] = useState(() => mkNewGame());
  const [toast, setToast] = useState(null);
  const toastTimer = useRef(null);

  const weaponObj = useMemo(() => WEAPONS.find((w) => w.key === state.player.weapon) || null, [state.player.weapon]);
  const styleObj = useMemo(
    () => WEAPONS.flatMap((w) => w.styles).find((s) => s.key === state.player.style) || null,
    [state.player.style]
  );
  const elementObj = useMemo(() => ELEMENTS.find((e) => e.key === state.player.element) || null, [state.player.element]);

  const skills = useMemo(
    () => skillListForBuild(state.player.weapon, state.player.style, state.player.element, state.player.crossStyle),
    [state.player.weapon, state.player.style, state.player.element, state.player.crossStyle]
  );

  const loc = useMemo(
    () => MAP_LOCATIONS.find(x => x.id === state.run.currentLocationId) || MAP_LOCATIONS[0],
    [state.run.currentLocationId]
  );

  const beaconHere = !!state.player.stationBuiltAt?.[loc.id];
  const safeHere = loc.kind === "safe" || beaconHere;

  const showToast = (msg) => {
    setToast(msg);
    if (toastTimer.current) clearTimeout(toastTimer.current);
    toastTimer.current = setTimeout(() => setToast(null), 2200);
  };

  const recalcPlayer = (draft) => {
    const w = WEAPONS.find((x) => x.key === draft.player.weapon);
    const bias = w?.bias || { might: 0, finesse: 0, wits: 0, will: 0 };
    draft.player.stats = computeStats(
      draft.player.baseStats,
      bias,
      draft.player.style,
      draft.player.element,
      draft.player.crossStyle
    );
    const hpBase = 10 + (draft.meta.legacy.startHP || 0);
    draft.player.hpMax = hpBase;
    draft.player.hp = clamp(draft.player.hp, 0, hpBase);
    draft.player.title = titleFromBuild(draft.player.weapon, draft.player.style, draft.player.element, draft.player.crossStyle);
  };

  const saveGame = () => {
    try { localStorage.setItem(SAVE_KEY, JSON.stringify(state)); showToast("Saved."); }
    catch { showToast("Save failed."); }
  };
  const loadGame = () => {
    try {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return showToast("No save found.");
      const parsed = JSON.parse(raw);
      if (!parsed?.version) return showToast("Save invalid.");
      setState(parsed);
      showToast("Loaded.");
    } catch { showToast("Load failed."); }
  };
  const clearSave = () => { try { localStorage.removeItem(SAVE_KEY); showToast("Save cleared."); } catch { showToast("Could not clear."); } };

  const hardReset = () => {
    const next = mkNewGame(Date.now());
    next.meta = state.meta; // carry meta
    next.player.hpMax = 10 + (next.meta.legacy.startHP || 0);
    next.player.hp = next.player.hpMax;
    pushLog(next, { type: "system", text: "New run started." });
    setState(next);
    showToast("New run.");
  };

  useEffect(() => {
    setState((prev) => {
      const draft = structuredClone(prev);
      if (draft.run.log.length) return prev; // don’t spam on re-mount
      pushLog(draft, { type: "story", text: "Dragons rule the skies. Cities survive as beacons. The Mountain Expanse pays in blood and salvage." });
      pushLog(draft, { type: "story", text: "Travel by named places. Only adjacent routes are possible." });
      pushLog(draft, { type: "story", text: "Promotions require XP. Only extracted loot endures—and extracted loot can be sold at safe places." });
      return draft;
    });
  }, []);

  // --- Early game flow: Weapon -> Style -> (play) ----------------------------

  const chooseWeapon = (weaponKey) => {
    setState((prev) => {
      const draft = structuredClone(prev);
      draft.player.weapon = weaponKey;
      recalcPlayer(draft);
      draft.phase = "chooseStyle";
      pushLog(draft, { type: "system", text: `Armament chosen: ${weaponKey.toUpperCase()}.` });
      return draft;
    });
  };

  const chooseStyle = (styleKey) => {
    setState((prev) => {
      const draft = structuredClone(prev);
      draft.player.style = styleKey;
      recalcPlayer(draft);

      draft.phase = "play";
      draft.run.depth = 1;
      draft.run.currentLocationId = "beacon_gate";
      draft.run.discovered = { beacon_gate: true };
      draft.run.cleared = {};
      draft.run.inCombat = false;
      draft.run.enemy = null;
      draft.run.enemyHP = 0;

      pushLog(draft, { type: "system", text: `Style chosen: ${styleKey.toUpperCase()}.` });
      pushLog(draft, { type: "story", text: "You are torn into light. Then—cold stone, thin air, and the smell of ash." });
      pushLog(draft, { type: "story", text: "The Beacon Gate receives you without joy." });
      return draft;
    });
  };

  // --- Encounters / Combat ---------------------------------------------------

  const startEncounterIfAllowed = (draft, location) => {
    // No encounters in safe places or beacon-built places
    const isBeacon = !!draft.player.stationBuiltAt?.[location.id];
    const isSafe = location.kind === "safe" || isBeacon;

    if (isSafe) {
      draft.run.inCombat = false;
      draft.run.enemy = null;
      draft.run.enemyHP = 0;
      return;
    }

    // Stations and events are “usually” safe unless you want later variants.
    // For now: station/event do not auto-fight; danger does.
    if (location.kind !== "danger") {
      draft.run.inCombat = false;
      draft.run.enemy = null;
      draft.run.enemyHP = 0;
      return;
    }

    // If already cleared, no fight on revisit (preview rule)
    if (draft.run.cleared?.[location.id]) {
      draft.run.inCombat = false;
      draft.run.enemy = null;
      draft.run.enemyHP = 0;
      return;
    }

    const localRng = mulberry32(draft.rngSeed ^ draft.run.depth ^ location.level ^ 0xBADA55);
    const enemy = pickEnemyForLevel(localRng, location.level);

    draft.run.inCombat = true;
    draft.run.enemy = { ...enemy, areaLevel: location.level };
    draft.run.enemyHP = enemy.hp + Math.floor(location.level / 2); // slight scaling
    pushLog(draft, { type: "story", text: `⚔️ ${enemy.name} appears (${location.name}). ${enemy.desc}` });
  };

  const takeDamage = (draft, amount, reason) => {
    draft.player.hp = clamp(draft.player.hp - amount, 0, draft.player.hpMax);
    pushLog(draft, { type: "system", text: `You take ${amount} damage (${reason}).` });
    if (draft.player.hp <= 0) {
      draft.phase = "dead";
      const echoes = 2 + draft.run.depth + Math.floor(draft.player.gold / 5);
      draft.meta.echoes += echoes;
      pushLog(draft, { type: "story", text: "☠️ You fall. The mountain keeps what you failed to extract." });
      pushLog(draft, { type: "system", text: `You gain ${echoes} Echoes at the Beacon.` });
    }
  };

  const enemyTurn = (draft, context = "combat") => {
    const enemy = draft.run.enemy;
    if (!enemy) return;

    const localRng = mulberry32(draft.rngSeed ^ draft.run.depth ^ 0x1111 ^ draft.run.enemyHP);
    const defMod = computeDefenseMod(draft.player.stats, draft.player.style);
    const defendActive = !!draft.run._defendActive;
    const braceBonus = defendActive ? 2 : 0;

    const check = rollCheck(localRng, `${enemy.name} attacks`, defMod + braceBonus, enemy.attackDR);
    pushLog(draft, { type: "roll", text: `${check.label}: d20 ${check.d20} ${fmtBonus(check.statBonus)} = ${check.total} vs DR ${check.dr} → ${check.success ? "HIT" : "MISS"}` });

    if (check.success) {
      let dmg = rollDamage(localRng, enemy.dmg[0], enemy.dmg[1]) + Math.floor((enemy.areaLevel || 1) / 3);
      if (defendActive) dmg = Math.max(0, dmg - 1 - (draft.player.element === "earth" ? 1 : 0));
      takeDamage(draft, dmg, context);
    } else {
      pushLog(draft, { type: "system", text: "You avoid the blow." });
    }
    draft.run._defendActive = false;
  };

  const dropLootFromLocation = (draft, location) => {
    const localRng = mulberry32(draft.rngSeed ^ draft.run.depth ^ location.level ^ 0xC0FFEE);
    const table = location.lootTable?.length ? location.lootTable : ["iron_shards"];
    const pick = table[Math.floor(localRng() * table.length)];
    const item = mkLootItem(pick, `${location.id}:${draft.run.depth}`);
    // slight value nudge by area level
    item.value = item.value + Math.max(0, location.level - 1);
    return item;
  };

  const endCombatWin = (draft) => {
    const location = MAP_LOCATIONS.find(x => x.id === draft.run.currentLocationId) || MAP_LOCATIONS[0];
    const loot = dropLootFromLocation(draft, location);

    draft.player.inventory.push(loot);

    const xpGain = 2; // keeps your original “a lil xp” cadence
    draft.player.xp += xpGain;

    draft.run.inCombat = false;
    draft.run.enemy = null;
    draft.run.enemyHP = 0;

    draft.run.cleared = draft.run.cleared || {};
    draft.run.cleared[location.id] = true;

    pushLog(draft, { type: "system", text: `Victory. Loot gained: ${loot.name} (value ${loot.value}). +${xpGain} XP.` });

    // Promotion unlock
    if (draft.player.promoTier === 0 && draft.player.xp >= draft.player.nextPromoAt) {
      draft.ui.showPromotion = true;
      pushLog(draft, { type: "story", text: "Something in you shifts. A new discipline is ready to bind." });
    }
  };

  const combatAction = (key) => {
    setState((prev) => {
      const draft = structuredClone(prev);
      if (draft.phase !== "play" || !draft.run.inCombat || !draft.run.enemy) return prev;

      const enemy = draft.run.enemy;
      const localRng = mulberry32(draft.rngSeed ^ draft.run.depth ^ 0x2222 ^ Date.now());

      const atkMod = computeAttackMod(draft.player.stats, draft.player.weapon);
      const defMod = computeDefenseMod(draft.player.stats, draft.player.style);

      const doAttack = (label, bonus, dmgMin, dmgMax, onMiss) => {
        const check = rollCheck(localRng, label, atkMod + bonus, enemy.dr);
        pushLog(draft, { type: "roll", text: `${check.label}: d20 ${check.d20} ${fmtBonus(check.statBonus)} = ${check.total} vs DR ${check.dr} → ${check.success ? "SUCCESS" : "FAIL"}` });

        if (check.success) {
          let dmg = rollDamage(localRng, dmgMin, dmgMax) + Math.floor((enemy.areaLevel || 1) / 3);
          if (check.d20 === 20) {
            dmg += 1;
            if (draft.player.element === "fire") dmg += 1;
            pushLog(draft, { type: "system", text: "Critical impact." });
          }
          draft.run.enemyHP = Math.max(0, draft.run.enemyHP - dmg);
          pushLog(draft, { type: "system", text: `Enemy takes ${dmg} damage.` });
          if (draft.run.enemyHP <= 0) { endCombatWin(draft); return; }
        } else {
          if (onMiss) onMiss();
        }
        if (draft.phase !== "dead") enemyTurn(draft, "combat");
      };

      if (key === "attack") { doAttack("You attack", 0, 1, 3); return draft; }

      if (key === "defend") {
        draft.run._defendActive = true;
        pushLog(draft, { type: "system", text: `You Brace (Defense mod ${fmtBonus(defMod)}).` });
        enemyTurn(draft, "brace");
        return draft;
      }

      if (key === "maneuver") {
        const check = rollCheck(localRng, "You Maneuver", draft.player.stats.wits + draft.player.stats.finesse, DR.standard);
        pushLog(draft, { type: "roll", text: `${check.label}: d20 ${check.d20} ${fmtBonus(check.statBonus)} = ${check.total} vs DR ${check.dr} → ${check.success ? "SUCCESS" : "FAIL"}` });
        if (check.success) pushLog(draft, { type: "system", text: "You gain Advantage (preview effect flavor-only for now)." });
        else takeDamage(draft, 1, "misstep");
        if (draft.phase !== "dead") enemyTurn(draft, "counter");
        return draft;
      }

      // Style specials
      if (key === "aim") { pushLog(draft, { type: "system", text: "You Aim. (Preview: +2 baked into this shot.)" }); doAttack("Aimed Shot", 2, 1, 4); return draft; }
      if (key === "dash") {
        const check = rollCheck(localRng, "Dash Shot", atkMod + 1, enemy.dr);
        pushLog(draft, { type: "roll", text: `${check.label}: d20 ${check.d20} ${fmtBonus(check.statBonus)} = ${check.total} vs DR ${check.dr} → ${check.success ? "SUCCESS" : "FAIL"}` });
        if (check.success) {
          const dmg = rollDamage(localRng, 1, 3);
          draft.run.enemyHP = Math.max(0, draft.run.enemyHP - dmg);
          pushLog(draft, { type: "system", text: `Enemy takes ${dmg} damage.` });
          if (draft.run.enemyHP <= 0) { endCombatWin(draft); return draft; }
          pushLog(draft, { type: "system", text: "You slip out of reach. No retaliation." });
          return draft;
        }
        enemyTurn(draft, "dash-fail");
        return draft;
      }
      if (key === "snare") { pushLog(draft, { type: "system", text: "You set a Snare. Enemy Attack DR +2 once." }); const old = enemy.attackDR; enemy.attackDR = old + 2; enemyTurn(draft, "snare"); enemy.attackDR = old; return draft; }
      if (key === "bolt") { doAttack("Arc Bolt", 1, 1, 5); return draft; }
      if (key === "hex") { const old = enemy.dr; enemy.dr = Math.max(8, enemy.dr - 2); pushLog(draft, { type: "system", text: "Hex: Enemy DR −2 this turn." }); doAttack("Hexed Strike", 0, 1, 2); enemy.dr = old; return draft; }
      if (key === "focus") { pushLog(draft, { type: "system", text: "You Focus. (Preview: +2 baked into next cast.)" }); doAttack("Focused Cast", 2, 1, 4); return draft; }
      if (key === "riposte") { doAttack("Shield-Check", 0, 1, 2); return draft; }
      if (key === "bleed") { doAttack("Open Vein", 0, 2, 4, () => takeDamage(draft, 1, "overextension")); return draft; }
      if (key === "lunge") { doAttack("Lunge", 1, 2, 5, () => takeDamage(draft, 2, "exposed")); return draft; }

      return draft;
    });
  };

  // --- Travel (adjacent named places) ---------------------------------------

  const travelTo = (toId) => {
    setState((prev) => {
      const draft = structuredClone(prev);
      if (draft.phase !== "play") return prev;
      if (draft.run.inCombat) { pushLog(draft, { type: "system", text: "You cannot travel during combat." }); return draft; }

      const from = MAP_LOCATIONS.find(x => x.id === draft.run.currentLocationId) || MAP_LOCATIONS[0];
      const to = MAP_LOCATIONS.find(x => x.id === toId);
      if (!to) return prev;

      const adjacent = (from.links || []).includes(toId) && (to.links || []).includes(from.id);
      if (!adjacent) { pushLog(draft, { type: "system", text: "That route is not adjacent." }); return draft; }

      draft.run.currentLocationId = toId;
      draft.run.depth += 1;
      draft.run.discovered[toId] = true;

      pushLog(draft, { type: "story", text: `You travel to: ${to.name}.` });
      pushLog(draft, { type: "story", text: to.tone });

      // Station hint
      if (to.kind === "station") {
        pushLog(draft, { type: "system", text: "A dormant relay sits here. If you build a beacon, this place becomes safe." });
      }

      // Start encounter if allowed by rules
      startEncounterIfAllowed(draft, to);

      return draft;
    });
  };

  // --- Rest / Build Beacon / Extract / Sell ---------------------------------

  const rest = () => {
    setState((prev) => {
      const draft = structuredClone(prev);
      if (draft.phase !== "play") return prev;
      if (draft.run.inCombat) { pushLog(draft, { type: "system", text: "No rest in combat." }); return draft; }

      const here = MAP_LOCATIONS.find(x => x.id === draft.run.currentLocationId) || MAP_LOCATIONS[0];
      const isBeacon = !!draft.player.stationBuiltAt?.[here.id];
      const isSafe = here.kind === "safe" || isBeacon;

      const heal = isSafe ? 3 : 2;
      draft.player.hp = clamp(draft.player.hp + heal, 0, draft.player.hpMax);
      pushLog(draft, { type: "system", text: `You rest (+${heal} HP).` });

      if (isSafe) {
        pushLog(draft, { type: "story", text: "No monsters here. The ward-light holds." });
      } else {
        // unsafe rest risk (preview)
        const localRng = mulberry32(draft.rngSeed ^ draft.run.depth ^ here.level ^ 0xAAAA ^ Date.now());
        if (localRng() < 0.45 && here.kind === "danger" && !draft.run.cleared?.[here.id]) {
          pushLog(draft, { type: "story", text: "You close your eyes. Something moves in the dark." });
          startEncounterIfAllowed(draft, here);
        } else {
          pushLog(draft, { type: "story", text: "The wind passes. No footsteps." });
        }
      }
      return draft;
    });
  };

  const buildBeacon = () => {
    setState((prev) => {
      const draft = structuredClone(prev);
      if (draft.phase !== "play") return prev;
      if (draft.run.inCombat) { pushLog(draft, { type: "system", text: "You cannot build during combat." }); return draft; }

      const here = MAP_LOCATIONS.find(x => x.id === draft.run.currentLocationId) || MAP_LOCATIONS[0];

      // Require Relay Parts in carried inventory
      const idx = draft.player.inventory.findIndex(it => it.key === "relay_parts");
      if (idx === -1) { pushLog(draft, { type: "system", text: "You lack Relay Parts to build a Beacon." }); return draft; }

      draft.player.inventory.splice(idx, 1);
      draft.player.stationBuiltAt = draft.player.stationBuiltAt || {};
      draft.player.stationBuiltAt[here.id] = true;

      // Once beacon exists, this location becomes safe (no more monsters here)
      draft.run.inCombat = false;
      draft.run.enemy = null;
      draft.run.enemyHP = 0;

      pushLog(draft, { type: "story", text: "You assemble a crude Beacon. A ward flickers to life… then steadies." });
      pushLog(draft, { type: "system", text: "This place is now SAFE. You can rest and extract without monster risk." });
      return draft;
    });
  };

  const extract = () => {
    setState((prev) => {
      const draft = structuredClone(prev);
      if (draft.phase !== "play") return prev;
      if (draft.run.inCombat) { pushLog(draft, { type: "system", text: "Extracting during combat is a good way to die." }); return draft; }

      const here = MAP_LOCATIONS.find(x => x.id === draft.run.currentLocationId) || MAP_LOCATIONS[0];
      const isBeacon = !!draft.player.stationBuiltAt?.[here.id];
      const isSafe = here.kind === "safe" || isBeacon || here.kind === "station";

      if (!isSafe) { pushLog(draft, { type: "system", text: "No secure station here. Build a Beacon or find a Relay/Safe place." }); return draft; }

      const items = draft.player.inventory.splice(0);
      draft.player.extracted.push(...items);

      pushLog(draft, { type: "system", text: `Extraction complete. Saved ${items.length} item(s).` });
      if (items.length) {
        pushLog(draft, { type: "system", text: `Extracted value: ${sumLootValue(items)} (sellable at safe places).` });
      }
      return draft;
    });
  };

  const sellExtracted = () => {
    setState((prev) => {
      const draft = structuredClone(prev);
      if (draft.phase !== "play") return prev;
      if (draft.run.inCombat) return prev;

      const here = MAP_LOCATIONS.find(x => x.id === draft.run.currentLocationId) || MAP_LOCATIONS[0];
      const isBeacon = !!draft.player.stationBuiltAt?.[here.id];
      const isSafe = here.kind === "safe" || isBeacon;

      if (!isSafe) { pushLog(draft, { type: "system", text: "No market here. Sell only at SAFE places (or your Beacon)." }); return draft; }

      const value = sumLootValue(draft.player.extracted);
      if (value <= 0) { pushLog(draft, { type: "system", text: "Nothing extracted to sell." }); return draft; }

      draft.player.gold += value;
      draft.player.extracted = [];
      pushLog(draft, { type: "system", text: `Sold extracted salvage for ${value} gold.` });
      return draft;
    });
  };

  // --- Promotion -------------------------------------------------------------

  const revealClass = (draft) => {
    draft.ui.showClassReveal = true;
    draft.ui.classRevealText = `You are now known as: ${draft.player.title}.`;
    pushLog(draft, { type: "story", text: `✦ ${draft.ui.classRevealText}` });
  };

  const choosePromotionElement = (elementKey) => {
    setState((prev) => {
      const draft = structuredClone(prev);
      draft.player.element = elementKey;
      draft.player.crossStyle = null;
      draft.player.promoTier = 1;
      draft.ui.showPromotion = false;
      recalcPlayer(draft);
      pushLog(draft, { type: "system", text: `Promotion: Affinity ${elementKey.toUpperCase()}.` });
      revealClass(draft);
      return draft;
    });
  };

  const choosePromotionCross = (crossStyleKey) => {
    setState((prev) => {
      const draft = structuredClone(prev);
      draft.player.crossStyle = crossStyleKey;
      draft.player.element = null;
      draft.player.promoTier = 1;
      draft.ui.showPromotion = false;
      recalcPlayer(draft);
      pushLog(draft, { type: "system", text: `Promotion: Cross-Training ${crossStyleKey.toUpperCase()}.` });
      revealClass(draft);
      return draft;
    });
  };

  // --- Death / Meta ----------------------------------------------------------

  const reviveToStart = () => {
    setState((prev) => {
      const draft = structuredClone(prev);
      if (draft.phase !== "dead") return draft;
      const next = mkNewGame(Date.now());
      next.meta = draft.meta;
      next.player.hpMax = 10 + (next.meta.legacy.startHP || 0);
      next.player.hp = next.player.hpMax;
      pushLog(next, { type: "system", text: "You wake at the Beacon. The mountain waits." });
      return next;
    });
  };

  const metaSpend = (key, cost, apply) => {
    setState((prev) => {
      const draft = structuredClone(prev);
      if (draft.meta.echoes < cost) { pushLog(draft, { type: "system", text: "Not enough Echoes." }); return draft; }
      draft.meta.echoes -= cost;
      apply(draft);
      pushLog(draft, { type: "system", text: `Beacon upgraded: ${key}.` });
      return draft;
    });
  };

  // --- Derived UI values -----------------------------------------------------

  const adjacentLocations = useMemo(() => {
    const from = MAP_LOCATIONS.find(x => x.id === state.run.currentLocationId) || MAP_LOCATIONS[0];
    const ids = from.links || [];
    return ids.map(id => MAP_LOCATIONS.find(x => x.id === id)).filter(Boolean);
  }, [state.run.currentLocationId]);

  const canExtractHere = useMemo(() => {
    if (state.phase !== "play") return false;
    const here = MAP_LOCATIONS.find(x => x.id === state.run.currentLocationId) || MAP_LOCATIONS[0];
    const isBeacon = !!state.player.stationBuiltAt?.[here.id];
    return here.kind === "safe" || here.kind === "station" || isBeacon;
  }, [state.phase, state.run.currentLocationId, state.player.stationBuiltAt]);

  // --- Render ----------------------------------------------------------------

  return (
    <div className="min-h-screen bg-[radial-gradient(80%_60%_at_50%_0%,rgba(124,58,237,0.28),rgba(0,0,0,0)),radial-gradient(70%_60%_at_20%_20%,rgba(14,165,233,0.18),rgba(0,0,0,0)),linear-gradient(to_bottom,rgba(0,0,0,1),rgba(9,9,11,1))] text-white">
      <div className="max-w-6xl mx-auto p-4 md:p-6">
        <div className="flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
          <div>
            <div className="text-sm text-white/60">DRAGONFALL • Mountain Exile • v{VERSION}</div>
            <div className="text-3xl md:text-4xl font-semibold tracking-tight">Arcane Run Preview</div>
            <div className="text-white/70 mt-1">map travel • adjacency routes • area-tier monsters • XP promotions • salvage economy</div>
          </div>
          <div className="flex flex-wrap gap-2">
            <Button onClick={saveGame} variant="ghost">Save</Button>
            <Button onClick={loadGame} variant="ghost">Load</Button>
            <Button onClick={clearSave} variant="ghost">Clear Save</Button>
            <Button onClick={hardReset} variant="danger">New Run</Button>
          </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-12 gap-4 mt-5">
          <div className="lg:col-span-8 flex flex-col gap-4">
            <Card
              title={`Chapter ${state.book.chapter} • Page ${state.book.page}`}
              subtitle={state.phase === "dead" ? "☠️ Fallen" : state.phase === "play" ? "In the Mountain" : "Preparation"}
              right={
                <div className="flex gap-2 flex-wrap justify-end">
                  <Pill>HP {state.player.hp}/{state.player.hpMax}</Pill>
                  <Pill>XP {state.player.xp}</Pill>
                  <Pill>Echoes {state.meta.echoes}</Pill>
                  <Pill>Gold {state.player.gold}</Pill>
                </div>
              }
            >
              {state.phase !== "play" ? (
                <div className="space-y-3">
                  <div className="text-white/80 leading-relaxed">
                    Dragons own the sky. Cities endure as beacons. You will be cast into the Mountain Expanse.
                    <span className="text-white font-semibold"> Promotions require XP.</span> Only extracted salvage endures—and extracted salvage buys power.
                  </div>

                  {state.ui.showClassTree ? (
                    <div className="rounded-2xl border border-white/10 bg-white/5 p-4">
                      <div className="flex items-center justify-between gap-3">
                        <div>
                          <div className="font-semibold">Class Lattice (visual)</div>
                          <div className="text-sm text-white/70">Weapon → Style → (Earn XP) → Element OR Cross → Title reveal</div>
                        </div>
                        <Button variant="ghost" onClick={() => setState((p) => ({ ...p, ui: { ...p.ui, showClassTree: false } }))}>
                          Hide
                        </Button>
                      </div>
                      <div className="mt-3">
                        <svg viewBox="0 0 100 48" className="w-full h-36">
                          <defs>
                            <linearGradient id="g" x1="0" x2="1">
                              <stop offset="0" stopColor="rgba(124,58,237,0.85)" />
                              <stop offset="1" stopColor="rgba(14,165,233,0.75)" />
                            </linearGradient>
                          </defs>
                          <path d="M10 24 C 24 10, 34 10, 46 16" stroke="url(#g)" strokeWidth="1.5" fill="none" opacity="0.8" />
                          <path d="M10 24 C 24 38, 34 38, 46 32" stroke="url(#g)" strokeWidth="1.5" fill="none" opacity="0.8" />
                          <path d="M46 16 L 70 12" stroke="url(#g)" strokeWidth="1.5" opacity="0.8" />
                          <path d="M46 16 L 70 22" stroke="url(#g)" strokeWidth="1.5" opacity="0.8" />
                          <path d="M46 32 L 70 26" stroke="url(#g)" strokeWidth="1.5" opacity="0.8" />
                          <path d="M46 32 L 70 36" stroke="url(#g)" strokeWidth="1.5" opacity="0.8" />
                          <path d="M70 12 L 90 18" stroke="url(#g)" strokeWidth="1.5" opacity="0.8" />
                          <path d="M70 36 L 90 30" stroke="url(#g)" strokeWidth="1.5" opacity="0.8" />

                          {[
                            { x: 4, y: 18, w: 12, h: 12, t: "Weapon" },
                            { x: 40, y: 10, w: 14, h: 12, t: "Style" },
                            { x: 40, y: 26, w: 14, h: 12, t: "Style" },
                            { x: 64, y: 6, w: 12, h: 12, t: "Element" },
                            { x: 64, y: 20, w: 12, h: 12, t: "Cross" },
                            { x: 64, y: 30, w: 12, h: 12, t: "Cross" },
                            { x: 84, y: 14, w: 12, h: 12, t: "Title" },
                            { x: 84, y: 26, w: 12, h: 12, t: "Title" },
                          ].map((b, i) => (
                            <g key={i}>
                              <rect x={b.x} y={b.y} width={b.w} height={b.h} rx="3"
                                fill="rgba(255,255,255,0.08)" stroke="rgba(255,255,255,0.18)" />
                              <text x={b.x + b.w / 2} y={b.y + 8} textAnchor="middle" fontSize="6" fill="rgba(255,255,255,0.85)">
                                {b.t}
                              </text>
                            </g>
                          ))}
                        </svg>
                      </div>
                      <div className="text-xs text-white/60">
                        First promotion unlocks at <span className="text-white font-semibold">{state.player.nextPromoAt} XP</span>.
                      </div>
                    </div>
                  ) : (
                    <Button variant="ghost" onClick={() => setState((p) => ({ ...p, ui: { ...p.ui, showClassTree: true } }))}>
                      Show Class Lattice
                    </Button>
                  )}

                  {state.phase === "start" ? (
                    <div className="space-y-3">
                      <div className="text-sm text-white/60">Choose your starting weapon.</div>
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                        {WEAPONS.map((w) => (
                          <button
                            key={w.key}
                            onClick={() => chooseWeapon(w.key)}
                            className={`rounded-2xl p-4 border text-left transition hover:bg-white/5 ${
                              state.player.weapon === w.key ? "border-white/40 bg-white/5" : "border-white/10"
                            }`}
                          >
                            <div className="text-lg font-semibold">{w.name}</div>
                            <div className="text-sm text-white/70 mt-1">{w.tagline}</div>
                            <div className="text-xs text-white/60 mt-3">
                              Bias: Might {fmtBonus(w.bias.might)} • Finesse {fmtBonus(w.bias.finesse)} • Wits {fmtBonus(w.bias.wits)} • Will {fmtBonus(w.bias.will)}
                            </div>
                          </button>
                        ))}
                      </div>
                    </div>
                  ) : null}

                  {state.phase === "chooseStyle" ? (
                    <div className="space-y-3">
                      <div className="text-sm text-white/60">Choose your weapon style.</div>
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                        {weaponObj?.styles.map((s) => (
                          <button
                            key={s.key}
                            onClick={() => chooseStyle(s.key)}
                            className="rounded-2xl p-4 border text-left transition hover:bg-white/5 border-white/10"
                          >
                            <div className="text-lg font-semibold">{s.name}</div>
                            <div className="text-sm text-white/70 mt-1">{s.desc}</div>
                          </button>
                        ))}
                      </div>
                    </div>
                  ) : null}

                  {state.phase === "dead" ? (
                    <div className="space-y-4">
                      <div className="text-white/80 leading-relaxed">
                        You are dead. The Beacon collects Echoes.
                      </div>
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                        <div className="rounded-2xl border border-white/10 p-4">
                          <div className="font-semibold">Beacon Upgrades</div>
                          <div className="text-xs text-white/60 mt-1">Account-wide.</div>
                          <Divider />
                          <div className="space-y-2">
                            <div className="flex items-center justify-between">
                              <div>
                                <div className="text-sm font-medium">Start HP +1</div>
                                <div className="text-xs text-white/60">Cost: 6 Echoes</div>
                              </div>
                              <Button variant="ghost" onClick={() => metaSpend("Start HP +1", 6, (d) => { d.meta.legacy.startHP += 1; })}>
                                Buy
                              </Button>
                            </div>
                            <div className="flex items-center justify-between">
                              <div>
                                <div className="text-sm font-medium">Reveal Hints +1</div>
                                <div className="text-xs text-white/60">Cost: 4 Echoes</div>
                              </div>
                              <Button variant="ghost" onClick={() => metaSpend("Reveal Hints +1", 4, (d) => { d.meta.legacy.revealHints += 1; })}>
                                Buy
                              </Button>
                            </div>
                          </div>
                        </div>

                        <div className="rounded-2xl border border-white/10 p-4">
                          <div className="font-semibold">Run Summary</div>
                          <Divider />
                          <div className="text-sm text-white/70">Depth reached: <span className="font-semibold text-white">{state.run.depth}</span></div>
                          <div className="text-sm text-white/70 mt-1">XP earned: <span className="font-semibold text-white">{state.player.xp}</span></div>
                          <div className="text-sm text-white/70 mt-1">Gold: <span className="font-semibold text-white">{state.player.gold}</span></div>
                        </div>

                        <div className="rounded-2xl border border-white/10 p-4">
                          <div className="font-semibold">Return</div>
                          <div className="text-sm text-white/70 mt-1">Begin a new run with Beacon upgrades.</div>
                          <Divider />
                          <Button onClick={reviveToStart}>Wake at the Beacon</Button>
                        </div>
                      </div>
                    </div>
                  ) : null}
                </div>
              ) : (
                <div className="space-y-3">
                  <div className="flex flex-wrap gap-2">
                    <Pill>Title: {state.player.title}</Pill>
                    <Pill>Weapon: {weaponObj?.name}</Pill>
                    <Pill>Style: {styleObj?.name}</Pill>
                    {elementObj ? <Pill>Affinity: {elementObj.name}</Pill> : null}
                    {state.player.crossStyle ? <Pill>Cross: {WEAPONS.flatMap(w => w.styles).find(s => s.key === state.player.crossStyle)?.name}</Pill> : null}
                    <Pill>Region: {loc.region}</Pill>
                    <Pill>Promo: {state.player.promoTier}/?</Pill>
                  </div>

                  <div className="rounded-2xl border border-white/10 p-4 bg-white/5">
                    <div className="flex items-start justify-between gap-3">
                      <div>
                        <div className="text-lg font-semibold">{loc.name}</div>
                        <div className="text-sm text-white/70 mt-1">{loc.tone}</div>
                      </div>
                      <div className="flex flex-col items-end gap-2">
                        <span className={`rounded-full px-2 py-1 text-xs border ${kindBadge(loc.kind, beaconHere).cls}`}>
                          {kindBadge(loc.kind, beaconHere).label} • LV {loc.level}
                        </span>
                        {state.run.cleared?.[loc.id] && loc.kind === "danger" ? (
                          <span className="text-xs text-white/60">Cleared</span>
                        ) : null}
                      </div>
                    </div>

                    {state.run.inCombat && state.run.enemy ? (
                      <div className="mt-3 flex items-center justify-between">
                        <div>
                          <div className="font-semibold">⚔️ {state.run.enemy.name}</div>
                          <div className="text-xs text-white/60">Enemy DR {state.run.enemy.dr} • Attack DR {state.run.enemy.attackDR} • Area LV {state.run.enemy.areaLevel}</div>
                        </div>
                        <div className="text-lg font-semibold">HP {state.run.enemyHP}/{state.run.enemy.hp + Math.floor((state.run.enemy.areaLevel||1)/2)}</div>
                      </div>
                    ) : (
                      <div className="mt-3 text-sm text-white/60">
                        {safeHere ? "Safe air. No monsters here." : loc.kind === "danger" ? "Danger territory. If it’s not cleared, it bites." : "Quiet ground. For now."}
                      </div>
                    )}
                  </div>

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div className="rounded-2xl border border-white/10 p-4">
                      <div className="font-semibold">World Map</div>
                      <div className="text-xs text-white/60 mt-1">Travel only to adjacent named places.</div>
                      <Divider />

                      <div className="rounded-2xl border border-white/10 bg-white/5 p-3">
                        <svg viewBox="0 0 100 100" className="w-full h-44">
                          {/* links */}
                          {MAP_LOCATIONS.flatMap((a) => (a.links || []).map((bId) => {
                            const b = MAP_LOCATIONS.find(x => x.id === bId);
                            if (!b) return null;
                            // draw each edge once
                            if (a.id > b.id) return null;
                            const near = a.id === state.run.currentLocationId || b.id === state.run.currentLocationId;
                            const aSeen = state.run.discovered?.[a.id];
                            const bSeen = state.run.discovered?.[b.id];
                            const fade = aSeen && bSeen ? 1 : 0.25;
                            return (
                              <line
                                key={`${a.id}-${b.id}`}
                                x1={a.coords.x} y1={a.coords.y}
                                x2={b.coords.x} y2={b.coords.y}
                                stroke={near ? "rgba(255,255,255,0.28)" : "rgba(255,255,255,0.12)"}
                                strokeWidth={1.5}
                                opacity={fade}
                              />
                            );
                          }))}

                          {/* nodes */}
                          {MAP_LOCATIONS.map((n) => {
                            const seen = !!state.run.discovered?.[n.id];
                            const isHere = n.id === state.run.currentLocationId;
                            const isBeacon = !!state.player.stationBuiltAt?.[n.id];
                            const fill =
                              isBeacon || n.kind === "safe" ? "rgba(34,197,94,0.18)"
                              : n.kind === "station" ? "rgba(14,165,233,0.16)"
                              : n.kind === "event" ? "rgba(99,102,241,0.16)"
                              : "rgba(239,68,68,0.20)";
                            const stroke = isHere ? "rgba(255,255,255,0.70)" : seen ? "rgba(255,255,255,0.28)" : "rgba(255,255,255,0.10)";
                            const opacity = seen ? 1 : 0.25;

                            return (
                              <g key={n.id} opacity={opacity}>
                                <circle cx={n.coords.x} cy={n.coords.y} r={6.5} fill={fill} stroke={stroke} strokeWidth={2} />
                                {isHere ? <circle cx={n.coords.x} cy={n.coords.y} r={10} fill="none" stroke="rgba(124,58,237,0.6)" strokeWidth={1.5} /> : null}
                              </g>
                            );
                          })}
                        </svg>

                        <div className="mt-2">
                          <div className="text-xs text-white/60">Adjacent routes from <span className="text-white font-semibold">{loc.name}</span>:</div>
                          <div className="flex flex-wrap gap-2 mt-2">
                            {adjacentLocations.map((n) => {
                              const isHere = n.id === state.run.currentLocationId;
                              const seen = !!state.run.discovered?.[n.id];
                              const isBeacon = !!state.player.stationBuiltAt?.[n.id];
                              const badge = kindBadge(n.kind, isBeacon);
                              return (
                                <Button
                                  key={n.id}
                                  variant={isHere ? "primary" : "ghost"}
                                  onClick={() => travelTo(n.id)}
                                  disabled={isHere || state.run.inCombat}
                                  title={n.tone}
                                >
                                  {seen ? "→" : "✦"} {n.name}
                                </Button>
                              );
                            })}
                          </div>
                        </div>
                      </div>

                      <Divider />
                      <div className="flex flex-wrap gap-2">
                        <Button variant="ghost" onClick={rest} disabled={state.run.inCombat}>Rest</Button>
                        <Button
                          variant="ghost"
                          onClick={buildBeacon}
                          disabled={state.run.inCombat || beaconHere}
                          title="Requires Relay Parts (carried). Makes this place safe."
                        >
                          {beaconHere ? "Beacon Built" : "Build Beacon"}
                        </Button>
                        <Button
                          variant="ghost"
                          onClick={extract}
                          disabled={!canExtractHere || state.run.inCombat}
                          title={canExtractHere ? "Move carried loot into extracted stash." : "Need safe/relay/beacon to extract."}
                        >
                          Extract
                        </Button>
                        <Button
                          variant="ghost"
                          onClick={sellExtracted}
                          disabled={state.run.inCombat}
                          title="Sell extracted salvage for gold (safe places only)."
                        >
                          Sell Extracted
                        </Button>
                      </div>
                    </div>

                    <div className="rounded-2xl border border-white/10 p-4">
                      <div className="font-semibold">Actions</div>
                      <div className="text-xs text-white/60 mt-1">Dice decide. Failure hurts.</div>
                      <Divider />

                      {state.run.inCombat ? (
                        <div className="flex flex-wrap gap-2">
                          <Button onClick={() => combatAction("attack")}>Attack</Button>
                          <Button variant="ghost" onClick={() => combatAction("defend")}>Brace</Button>
                          <Button variant="ghost" onClick={() => combatAction("maneuver")}>Maneuver</Button>
                          {skills
                            .filter((s) => s.kind === "action" && !["attack","defend","maneuver"].includes(s.key))
                            .map((s) => (
                              <Button key={s.key} variant="ghost" onClick={() => combatAction(s.key)}>
                                {s.name}
                              </Button>
                            ))}
                        </div>
                      ) : (
                        <div className="text-sm text-white/70">
                          Travel via adjacent routes.
                          {state.player.promoTier === 0 ? (
                            <div className="mt-2 text-xs text-white/60">
                              Earn <span className="text-white font-semibold">{Math.max(0, state.player.nextPromoAt - state.player.xp)}</span> more XP to unlock your first specialization.
                            </div>
                          ) : null}
                          {safeHere ? (
                            <div className="mt-2 text-xs text-white/60">This place is safe. Resting will never trigger monsters.</div>
                          ) : null}
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              )}
            </Card>

            <Card title="Event Log" subtitle="Newest first. Rolls are explicit.">
              <div className="space-y-2">
                {state.run.log.length === 0 ? (
                  <div className="text-white/60 text-sm">No events yet.</div>
                ) : (
                  state.run.log.map((l) => (
                    <div
                      key={l.id}
                      className={`rounded-xl border px-3 py-2 text-sm ${
                        l.type === "roll" ? "border-amber-400/20 bg-amber-500/10"
                        : l.type === "system" ? "border-white/10 bg-white/5"
                        : "border-indigo-400/20 bg-indigo-500/10"
                      }`}
                    >
                      <div className="text-white/90">{l.text}</div>
                    </div>
                  ))
                )}
              </div>
            </Card>
          </div>

          <div className="lg:col-span-4 flex flex-col gap-4">
            <Card title="Character" subtitle="Stats, skills, salvage economy">
              <div className="flex flex-wrap gap-2">
                <Pill>HP {state.player.hp}/{state.player.hpMax}</Pill>
                <Pill>XP {state.player.xp}</Pill>
                <Pill>Gold {state.player.gold}</Pill>
                <Pill>Carry Value {sumLootValue(state.player.inventory)}</Pill>
                <Pill>Extracted Value {sumLootValue(state.player.extracted)}</Pill>
              </div>

              <Divider />
              <div className="grid grid-cols-2 gap-3">
                {["might","finesse","wits","will"].map((k) => (
                  <div key={k} className="rounded-xl border border-white/10 p-3">
                    <div className="text-xs text-white/60">{k.toUpperCase()}</div>
                    <div className="text-lg font-semibold">{fmtBonus(state.player.stats[k])}</div>
                  </div>
                ))}
              </div>

              <Divider />
              <div className="text-sm font-semibold">Skills</div>
              <div className="space-y-2 mt-2">
                {skills.map((s) => (
                  <div key={s.key} className="rounded-xl border border-white/10 p-3">
                    <div className="flex items-center justify-between">
                      <div className="font-medium">{s.name}</div>
                      <span className="text-xs text-white/50">{s.kind}</span>
                    </div>
                    <div className="text-xs text-white/60 mt-1">{s.desc}</div>
                  </div>
                ))}
              </div>

              <Divider />
              <div className="text-sm font-semibold">Inventory (carried)</div>
              <div className="text-sm text-white/70 mt-2">
                {state.player.inventory.length ? (
                  <ul className="space-y-2">
                    {state.player.inventory.map((it) => (
                      <li key={it.id} className="rounded-xl border border-white/10 p-3 bg-white/5">
                        <div className="flex items-start justify-between gap-2">
                          <div>
                            <div className="font-medium">{it.name}</div>
                            <div className="text-xs text-white/60 mt-1">{it.desc}</div>
                          </div>
                          <Pill>Value {it.value}</Pill>
                        </div>
                      </li>
                    ))}
                  </ul>
                ) : <div className="text-white/50">Empty.</div>}
              </div>

              <Divider />
              <div className="text-sm font-semibold">Extracted (saved)</div>
              <div className="text-sm text-white/70 mt-2">
                {state.player.extracted.length ? (
                  <ul className="space-y-2">
                    {state.player.extracted.map((it) => (
                      <li key={it.id} className="rounded-xl border border-white/10 p-3">
                        <div className="flex items-start justify-between gap-2">
                          <div>
                            <div className="font-medium">{it.name}</div>
                            <div className="text-xs text-white/60 mt-1">{it.desc}</div>
                          </div>
                          <Pill>Value {it.value}</Pill>
                        </div>
                      </li>
                    ))}
                  </ul>
                ) : <div className="text-white/50">None yet.</div>}
              </div>
            </Card>

            <Card title="Help" subtitle="What changed in v0.3">
              <div className="text-sm text-white/70 leading-relaxed space-y-2">
                <div><span className="font-semibold text-white">Map travel:</span> you move between <span className="font-semibold text-white">named locations</span> using adjacent routes.</div>
                <div><span className="font-semibold text-white">Area monsters:</span> danger locations spawn enemies based on area level.</div>
                <div><span className="font-semibold text-white">Safe rests:</span> safe places (and built beacons) have <span className="font-semibold text-white">no monsters</span>.</div>
                <div><span className="font-semibold text-white">Loot value:</span> salvage has meaning + value. Extract it, then sell it in safe places.</div>
                <div><span className="font-semibold text-white">Specialization:</span> at {state.player.nextPromoAt} XP choose <span className="font-semibold text-white">Element OR Cross</span>, then you get a class-title reveal.</div>
              </div>
            </Card>
          </div>
        </div>
      </div>

      {/* Promotion Modal */}
      {state.phase === "play" && state.ui.showPromotion ? (
        <div className="fixed inset-0 bg-black/60 flex items-center justify-center p-4">
          <div className="max-w-2xl w-full rounded-2xl border border-white/10 bg-zinc-950/80 backdrop-blur p-4">
            <div className="flex items-start justify-between gap-3">
              <div>
                <div className="text-xl font-semibold">Specialization Unlocked</div>
                <div className="text-sm text-white/70 mt-1">Choose one: bind an Element, or cross-train a Style. Then you’ll receive your class title.</div>
              </div>
              <Button variant="ghost" onClick={() => setState((p) => ({ ...p, ui: { ...p.ui, showPromotion: false } }))}>
                Later
              </Button>
            </div>
            <Divider />
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              <div className="rounded-2xl border border-white/10 p-4 bg-white/5">
                <div className="font-semibold">Bind an Element</div>
                <div className="text-sm text-white/70 mt-1">Sharper identity. Titles evolve.</div>
                <div className="grid grid-cols-2 gap-2 mt-3">
                  {ELEMENTS.map((e) => (
                    <Button key={e.key} variant="ghost" onClick={() => choosePromotionElement(e.key)}>
                      {e.name}
                    </Button>
                  ))}
                </div>
              </div>

              <div className="rounded-2xl border border-white/10 p-4 bg-white/5">
                <div className="font-semibold">Cross-Train a Style</div>
                <div className="text-sm text-white/70 mt-1">More options. Less raw power.</div>
                <div className="grid grid-cols-2 gap-2 mt-3">
                  {WEAPONS.flatMap((w) => w.styles)
                    .filter((s) => s.key !== state.player.style)
                    .slice(0, 8)
                    .map((s) => (
                      <Button key={s.key} variant="ghost" onClick={() => choosePromotionCross(s.key)}>
                        {s.name}
                      </Button>
                    ))}
                </div>
                <div className="text-xs text-white/50 mt-2">(Preview: curated list for now.)</div>
              </div>
            </div>
          </div>
        </div>
      ) : null}

      {/* Class Reveal Modal */}
      {state.phase === "play" && state.ui.showClassReveal ? (
        <div className="fixed inset-0 bg-black/60 flex items-center justify-center p-4">
          <div className="max-w-xl w-full rounded-2xl border border-white/10 bg-zinc-950/80 backdrop-blur p-4">
            <div className="text-xl font-semibold">Name Claimed</div>
            <div className="text-sm text-white/70 mt-2">
              {state.ui.classRevealText || `You are now known as: ${state.player.title}.`}
            </div>
            <Divider />
            <div className="flex justify-end gap-2">
              <Button variant="ghost" onClick={() => setState(p => ({ ...p, ui: { ...p.ui, showClassReveal: false } }))}>
                Continue
              </Button>
            </div>
          </div>
        </div>
      ) : null}

      {/* Toast */}
      {toast ? (
        <div className="fixed bottom-4 left-1/2 -translate-x-1/2">
          <div className="rounded-full bg-white text-black px-4 py-2 text-sm shadow-xl">{toast}</div>
        </div>
      ) : null}
    </div>
  );
}

ReactDOM.render(
  React.createElement(DragonfallMountainExilePreview),
  document.getElementById("root")
);
    </script>
  </body>
</html>
