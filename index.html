<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dragonfall Preview</title>

    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Game-ish fonts (CDN, no build step) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
      href="https://fonts.googleapis.com/css2?family=Cinzel:wght@500;700&family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />

    <!-- React (UMD builds) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel so we can run JSX in-browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      :root{
        --ui-bg: rgba(8,8,10,0.58);
        --ui-bg2: rgba(12,12,16,0.72);
        --ui-border: rgba(255,255,255,0.12);
        --ui-border2: rgba(255,255,255,0.18);
        --ui-glow: rgba(124,58,237,0.22);
      }
      html, body { height:100%; }
      body { margin:0; }

      /* game frame vibe */
      .ui-panel{
        background: linear-gradient(180deg, rgba(20,20,26,0.55), rgba(10,10,14,0.72));
        border: 1px solid var(--ui-border);
        box-shadow:
          0 20px 60px rgba(0,0,0,0.55),
          0 0 0 1px rgba(255,255,255,0.06) inset,
          0 0 40px var(--ui-glow);
        backdrop-filter: blur(10px);
      }
      .ui-panel-soft{
        background: var(--ui-bg);
        border: 1px solid var(--ui-border);
        box-shadow: 0 0 0 1px rgba(255,255,255,0.06) inset;
        backdrop-filter: blur(10px);
      }
      .ui-title{
        font-family: Cinzel, serif;
        letter-spacing: 0.02em;
      }
      .ui-runic{
        font-family: "Press Start 2P", monospace;
        font-size: 10px;
        letter-spacing: 0.12em;
      }

      /* Tooltip */
      .tt-wrap{ position: relative; display:inline-flex; }
      .tt{
        position:absolute;
        left: 50%;
        transform: translateX(-50%);
        bottom: calc(100% + 10px);
        width: min(320px, 72vw);
        pointer-events:none;
        opacity:0;
        transition: opacity 140ms ease, transform 140ms ease;
        z-index: 99;
      }
      .tt-wrap:hover .tt{
        opacity:1;
        transform: translateX(-50%) translateY(-2px);
      }
      .tt-box{
        border-radius: 16px;
        background: rgba(0,0,0,0.65);
        border: 1px solid rgba(255,255,255,0.12);
        box-shadow: 0 22px 60px rgba(0,0,0,0.55);
        padding: 10px 12px;
      }
      .tt-arrow{
        width: 14px; height: 14px;
        background: rgba(0,0,0,0.65);
        border-left: 1px solid rgba(255,255,255,0.12);
        border-bottom: 1px solid rgba(255,255,255,0.12);
        transform: rotate(-45deg);
        margin: -7px auto 0 auto;
      }

      /* Transition overlay */
      .wipe{
        animation: wipeIn 220ms ease-out forwards;
      }
      @keyframes wipeIn{
        from{ opacity:0; transform: translateY(6px) scale(0.99); }
        to{ opacity:1; transform: translateY(0) scale(1); }
      }
    </style>
  </head>

  <body class="bg-zinc-950">
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState } = React;

      // =========================================================
      // DRAGONFALL: MOUNTAIN EXILE — v0.4
      // Wave changes:
      // - "Game UI" treatment + pixel-art canvas backdrops (generated art)
      // - Transition cards that summarize what changed (combat, travel, events, menu choices)
      // - Map uses simple icons for locations
      // - Hostile action set: Explore (combat/event odds), Stir Up No Good (force combat),
      //   Rest, Extract, Open Map, Build Beacon
      // - Hover tooltips show odds + factors
      // - Random Events: big resource, stat boon, rare borrowed ability, affinity attack
      // =========================================================
      const VERSION = "0.4.0";
      const SAVE_KEY = "dragonfall_save_v04";

      function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
      function uid() { return Math.random().toString(16).slice(2) + Date.now().toString(16); }

      // Deterministic-ish RNG (mulberry32)
      function mulberry32(seed) {
        let a = seed >>> 0;
        return function () {
          a |= 0; a = (a + 0x6d2b79f5) | 0;
          let t = Math.imul(a ^ (a >>> 15), 1 | a);
          t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }
      function rollDie(rng, sides) { return 1 + Math.floor(rng() * sides); }
      function fmtBonus(b) { if (b === 0) return "+0"; return b > 0 ? `+${b}` : `${b}`; }

      const DR = { easy: 10, standard: 13, hard: 16, extreme: 19 };

      // --- Build system (weapon/style + promotions) ---
      const WEAPONS = [
        {
          key: "sword",
          name: "Sword",
          tagline: "Close combat • control • endurance",
          bias: { might: 1, finesse: 1, wits: 0, will: 0 },
          styles: [
            { key: "guard", name: "Guard", desc: "Defense, counters, zone control." },
            { key: "edge", name: "Edge", desc: "Precision, crits, bleed." },
            { key: "fury", name: "Fury", desc: "Momentum, risk, finishing." },
          ],
        },
        {
          key: "bow",
          name: "Bow",
          tagline: "Range • positioning • tempo",
          bias: { might: 0, finesse: 2, wits: 1, will: 0 },
          styles: [
            { key: "sniper", name: "Sniper", desc: "Single-target lethality." },
            { key: "skirmisher", name: "Skirmisher", desc: "Mobility, rapid shots." },
            { key: "trapper", name: "Trapper", desc: "Terrain control, prep." },
          ],
        },
        {
          key: "wand",
          name: "Wand",
          tagline: "Channeling • volatility • rituals",
          bias: { might: 0, finesse: 0, wits: 1, will: 2 },
          styles: [
            { key: "invoker", name: "Invoker", desc: "Raw spellcasting." },
            { key: "binder", name: "Binder", desc: "Debuffs, wards, control." },
            { key: "channeler", name: "Channeler", desc: "Sustained power, scaling." },
          ],
        },
      ];

      const ELEMENTS = [
        { key: "fire", name: "Fire", vibe: "Escalation • burning risk" },
        { key: "ice", name: "Ice", vibe: "Control • delay • precision" },
        { key: "storm", name: "Storm", vibe: "Speed • chaining chaos" },
        { key: "earth", name: "Earth", vibe: "Endurance • retaliation" },
        { key: "void", name: "Void", vibe: "Sacrifice • inversion" },
      ];

      function computeStats(base, weaponBias, styleKey, elementKey, crossKey, runBuff) {
        const s = { ...base };
        for (const k of Object.keys(weaponBias)) s[k] += weaponBias[k];

        if (styleKey) {
          const map = {
            guard: { might: 1 }, edge: { finesse: 1 }, fury: { might: 1 },
            sniper: { finesse: 1, wits: 1 }, skirmisher: { finesse: 1 }, trapper: { wits: 2 },
            invoker: { wits: 1, will: 1 }, binder: { wits: 1, will: 1 }, channeler: { will: 2 },
          };
          const add = map[styleKey] || {};
          for (const k of Object.keys(add)) s[k] = (s[k] || 0) + add[k];
        }

        if (elementKey) {
          const map = {
            fire: { might: 1 },
            ice: { finesse: 1 },
            storm: { will: 1 },
            earth: { might: 1 },
            void: { will: 1 },
          };
          const add = map[elementKey] || {};
          for (const k of Object.keys(add)) s[k] = (s[k] || 0) + add[k];
        }

        // Cross-training = flexibility, less raw
        if (crossKey) { s.wits += 1; s.finesse += 1; s.might -= 1; }

        // run buffs (from events)
        if (runBuff) {
          for (const k of ["might","finesse","wits","will"]) s[k] += (runBuff[k] || 0);
        }

        s.might = clamp(s.might || 0, -1, 7);
        s.finesse = clamp(s.finesse || 0, -1, 7);
        s.wits = clamp(s.wits || 0, -1, 7);
        s.will = clamp(s.will || 0, -1, 7);
        return s;
      }

      function titleFromBuild(weaponKey, styleKey, elementKey, crossStyle) {
        const weapon = WEAPONS.find((w) => w.key === weaponKey)?.name || "";
        const style = WEAPONS.flatMap((w) => w.styles).find((s) => s.key === styleKey)?.name || "";
        const el = ELEMENTS.find((e) => e.key === elementKey)?.name || "";

        if (!weaponKey) return "Unbound";
        if (!styleKey) return weapon;

        if (crossStyle) {
          const crossName = WEAPONS.flatMap((w) => w.styles).find((s) => s.key === crossStyle)?.name || "Cross";
          return `${weapon} ${style} • ${crossName}`;
        }

        if (elementKey) {
          const suffixMap = {
            Guard: "Sentinel", Edge: "Duelist", Fury: "Reaver",
            Sniper: "Marksman", Skirmisher: "Rover", Trapper: "Warden",
            Invoker: "Invoker", Binder: "Binder", Channeler: "Channeler",
          };
          return `${el}${weapon} ${suffixMap[style] || "Adept"}`;
        }

        return `${weapon} ${style}`;
      }

      // --- Skills (combat buttons) ---
      function skillListForBuild(weaponKey, styleKey, elementKey, crossStyle, extraSkills) {
        const base = [];
        const attackLabel = weaponKey === "bow" ? "Shoot" : weaponKey === "wand" ? "Cast" : "Strike";
        base.push({ key: "attack", name: attackLabel, kind: "action", desc: "Roll to hit. On success, deal damage." });
        base.push({ key: "defend", name: "Brace", kind: "action", desc: "Raise defense this round. Reduce damage on hit." });
        base.push({ key: "maneuver", name: "Maneuver", kind: "action", desc: "Reposition to set up advantage." });

        const specials = {
          guard: { key: "riposte", name: "Shield-Check", desc: "A controlled shove. Safe, reliable." },
          edge: { key: "bleed", name: "Open Vein", desc: "Higher damage; risk a bite-back." },
          fury: { key: "lunge", name: "Lunge", desc: "Big swing; missing hurts." },
          sniper: { key: "aim", name: "Aim", desc: "Take a breath; next shot hits harder." },
          skirmisher: { key: "dash", name: "Dash Shot", desc: "Attack and slip away on success." },
          trapper: { key: "snare", name: "Snare", desc: "Hinder the next enemy attack." },
          invoker: { key: "bolt", name: "Arc Bolt", desc: "High variance magic strike." },
          binder: { key: "hex", name: "Hex", desc: "Weaken defenses, then hit." },
          channeler: { key: "focus", name: "Focus", desc: "Charge power; next roll +2." },
        };
        if (styleKey && specials[styleKey]) base.push({ ...specials[styleKey], kind: "action" });

        const elementPassives = {
          fire: "Fire: crits scorch (+1).",
          ice: "Ice: maneuvers slow (enemy −1 next roll).",
          storm: "Storm: once per scene, reroll a d20.",
          earth: "Earth: Brace reduces +1 extra damage.",
          void: "Void: when low HP, +1 to Will rolls.",
        };
        if (elementKey) base.push({ key: `passive_${elementKey}`, name: "Affinity", kind: "passive", desc: elementPassives[elementKey] });

        if (crossStyle) {
          const crossName = WEAPONS.flatMap((w) => w.styles).find((s) => s.key === crossStyle)?.name || "Cross";
          base.push({ key: "cross", name: "Cross-Training", kind: "passive", desc: `You carry a slice of ${crossName}.` });
        }

        // event-granted extra skills
        if (Array.isArray(extraSkills)) {
          for (const s of extraSkills) base.push(s);
        }

        return base;
      }

      // --- Combat math ---
      function rollCheck(rng, label, statBonus, dr) {
        const d20 = rollDie(rng, 20);
        const total = d20 + statBonus;
        return { label, d20, statBonus, total, dr, success: total >= dr };
      }
      function rollDamage(rng, min, max) { return min + Math.floor(rng() * (max - min + 1)); }

      function computeAttackMod(stats, weaponKey) {
        if (weaponKey === "sword") return stats.might + Math.floor(stats.finesse / 2);
        if (weaponKey === "bow") return stats.finesse + Math.floor(stats.wits / 2);
        if (weaponKey === "wand") return stats.will + Math.floor(stats.wits / 2);
        return 0;
      }
      function computeDefenseMod(stats, styleKey) {
        let mod = Math.floor((stats.might + stats.will) / 2);
        if (styleKey === "guard") mod += 1;
        if (styleKey === "trapper") mod += 1;
        if (styleKey === "binder") mod += 1;
        return mod;
      }

      // --- Materials (loot with meaning) ---
      const MATERIALS = [
        { key: "scaled_fragment", name: "Scaled Fragment", tier: 1, desc: "Warm to the touch. It remembers fire." },
        { key: "bright_glass", name: "Bright Glass", tier: 1, desc: "A shard that catches moonlight like a blade." },
        { key: "ward_coil", name: "Ward Coil", tier: 2, desc: "Copper thread humming with old equations." },
        { key: "beacon_ink", name: "Beacon Ink", tier: 1, desc: "Ink that stains even stone. Used for sigils." },
        { key: "relay_parts", name: "Relay Parts", tier: 2, desc: "A cracked lens and a broken core. Still useful." },
        { key: "void_chit", name: "Void Chit", tier: 3, desc: "A token that should not exist. It does anyway." },
      ];
      function mat(key) { return MATERIALS.find(m => m.key === key); }

      // --- Monster ecology (outer->inner scaling) ---
      const ENEMIES = [
        // OUTER (tier 1)
        { key: "ashwolf", tier: 1, name: "Ash-Wolf", hp: 10, dr: 12, attackDR: 12, dmg: [2, 4],
          desc: "Grey fur dusted in ember. It circles like a hungry thought." },
        { key: "wyrmling", tier: 1, name: "Wyrmling Scout", hp: 9, dr: 12, attackDR: 13, dmg: [1, 4],
          desc: "A juvenile dragonkin with a barbed spear and too much confidence." },
        { key: "cliff_ghoul", tier: 1, name: "Cliff Ghoul", hp: 8, dr: 11, attackDR: 12, dmg: [1, 3],
          desc: "It crawls on rock like a bad memory refusing burial." },

        // MID (tier 2)
        { key: "cultist", tier: 2, name: "Scalebound Cultist", hp: 12, dr: 13, attackDR: 14, dmg: [2, 5],
          desc: "Eyes like candles. The air around them tastes of coin and smoke." },
        { key: "drake_rider", tier: 2, name: "Drake-Rider", hp: 13, dr: 14, attackDR: 14, dmg: [2, 6],
          desc: "A rider and beast moving as one—trained cruelty, practiced speed." },
        { key: "ember_knight", tier: 2, name: "Ember Knight", hp: 14, dr: 14, attackDR: 15, dmg: [3, 6],
          desc: "Armor scorched shut. Something still wears it from within." },

        // INNER (tier 3)
        { key: "void_maw", tier: 3, name: "Void Maw", hp: 16, dr: 15, attackDR: 16, dmg: [3, 7],
          desc: "A mouth where light goes to die. It speaks without words." },
        { key: "wyrm_champion", tier: 3, name: "Wyrm Champion", hp: 18, dr: 16, attackDR: 16, dmg: [4, 8],
          desc: "A crowned brute of scale and oath—its breath is law." },
        { key: "spire_seraph", tier: 3, name: "Spire Seraph", hp: 17, dr: 16, attackDR: 17, dmg: [3, 9],
          desc: "Wings of glass. Halo of wire. Mercy absent." },
      ];

      // --- The mountain map (named places + adjacency, difficulty inward) ---
      // Tier: 1 outer, 2 mid, 3 inner
      // Kind: safe | wild | ruin | beacon | pass | shrine
      const LOCATIONS = [
        // OUTER RING (tier 1)
        { id: "l_beacon_gate", tier: 1, kind: "beacon", name: "Beacon Gate", x: 14, y: 78,
          lore: "The last light before the climb. The Beacon watches, patient as a judge." },
        { id: "l_ashway_bridge", tier: 1, kind: "pass", name: "Ashway Bridge", x: 26, y: 70,
          lore: "Black water churns beneath a cracked span. Wind howls through broken stone ribs." },
        { id: "l_moss_hollow", tier: 1, kind: "safe", name: "Moss Hollow", x: 18, y: 62,
          lore: "A shallow vale where green still dares to exist. The air tastes less sharp." },
        { id: "l_saltcut_trail", tier: 1, kind: "wild", name: "Saltcut Trail", x: 33, y: 60,
          lore: "A narrow path etched by old caravans. Salt crunches underfoot like teeth." },
        { id: "l_ruined_relay", tier: 1, kind: "ruin", name: "Ruined Relay", x: 40, y: 76,
          lore: "A collapsed outpost with a dormant crystal core. Someone died here recently." },

        // MID RING (tier 2)
        { id: "l_cinder_market", tier: 2, kind: "safe", name: "Cinder Market", x: 45, y: 52,
          lore: "Canvas tents. Whispered prices. A place where desperate people pretend they are fine." },
        { id: "l_wyrm_path", tier: 2, kind: "wild", name: "Wyrm Path", x: 56, y: 62,
          lore: "Claw marks score the rock. Heat breathes from the cracks like a sleeping furnace." },
        { id: "l_sigil_shrine", tier: 2, kind: "shrine", name: "Sigil Shrine", x: 58, y: 44,
          lore: "A ring of stone inscribed with rules the mountain refuses to obey." },
        { id: "l_broken_sprawl", tier: 2, kind: "ruin", name: "Broken Sprawl", x: 38, y: 40,
          lore: "A city’s ribs. Streets like scars. You hear the old noise if you stand still." },

        // INNER RING (tier 3)
        { id: "l_glass_valley", tier: 3, kind: "wild", name: "Glass Valley", x: 64, y: 32,
          lore: "The ground is glittering shards. Every step sounds like confession." },
        { id: "l_spire_pass", tier: 3, kind: "pass", name: "Spire Pass", x: 72, y: 44,
          lore: "The wind is louder here. It speaks in clipped syllables—like commands." },
        { id: "l_void_seam", tier: 3, kind: "ruin", name: "Void Seam", x: 80, y: 30,
          lore: "A tear in the world stitched shut with bad faith. It leaks cold geometry." },
        { id: "l_peak_crown", tier: 3, kind: "shrine", name: "The Crown Peak", x: 84, y: 18,
          lore: "A summit like an altar. The sky feels closer. The mountain feels alive." },
      ];

      const CONNECTIONS = [
        // Outer
        ["l_beacon_gate","l_moss_hollow"],
        ["l_beacon_gate","l_ashway_bridge"],
        ["l_moss_hollow","l_saltcut_trail"],
        ["l_ashway_bridge","l_saltcut_trail"],
        ["l_ashway_bridge","l_ruined_relay"],
        ["l_saltcut_trail","l_ruined_relay"],

        // Outer -> Mid
        ["l_saltcut_trail","l_cinder_market"],
        ["l_ruined_relay","l_wyrm_path"],
        ["l_cinder_market","l_broken_sprawl"],

        // Mid
        ["l_cinder_market","l_sigil_shrine"],
        ["l_broken_sprawl","l_sigil_shrine"],
        ["l_wyrm_path","l_sigil_shrine"],

        // Mid -> Inner
        ["l_sigil_shrine","l_glass_valley"],
        ["l_sigil_shrine","l_spire_pass"],
        ["l_glass_valley","l_void_seam"],
        ["l_spire_pass","l_void_seam"],
        ["l_spire_pass","l_peak_crown"],
        ["l_void_seam","l_peak_crown"],
      ];

      function locById(id) { return LOCATIONS.find(l => l.id === id) || null; }
      function neighborsOf(id) {
        const set = new Set();
        for (const [a,b] of CONNECTIONS) {
          if (a === id) set.add(b);
          if (b === id) set.add(a);
        }
        return [...set];
      }

      function isSafeLocation(location, builtBeacons) {
        if (!location) return false;
        if (location.kind === "safe" || location.kind === "beacon") return true;
        return builtBeacons.includes(location.id);
      }

      const REGION_NAME = { 1: "Outer Slopes", 2: "Cinder Valleys", 3: "Inner Spires" };

      function pickEnemyByTier(rng, tier) {
        const pool = ENEMIES.filter(e => e.tier === tier);
        return pool[Math.floor(rng() * pool.length)];
      }

      function pickMaterialDrop(rng, tier) {
        const pool = MATERIALS.filter(m => m.tier <= tier);
        const weighted = [];
        for (const m of pool) {
          const w = 1 + (m.tier === tier ? 2 : 0);
          for (let i=0;i<w;i++) weighted.push(m);
        }
        return weighted[Math.floor(rng() * weighted.length)];
      }

      // --- Beacon upgrades (Echoes + banked materials) ---
      const BEACON_UPGRADES = [
        {
          key: "start_hp",
          name: "Stoneheart (+1 Start HP)",
          desc: "Your body remembers impact. You wake sturdier each exile.",
          costEchoes: 6,
          costMats: { scaled_fragment: 2 },
          apply: (g) => { g.meta.legacy.startHP = (g.meta.legacy.startHP || 0) + 1; },
        },
        {
          key: "map_reveal",
          name: "Cartographer (+1 Reveal Depth)",
          desc: "The Beacon shows you more of the mountain at once.",
          costEchoes: 4,
          costMats: { bright_glass: 2, beacon_ink: 1 },
          apply: (g) => { g.meta.legacy.revealHints = (g.meta.legacy.revealHints || 0) + 1; },
        },
        {
          key: "safe_rest",
          name: "Quiet Ward (Safer Rests)",
          desc: "Your safe places become truly safe. Healing improves there.",
          costEchoes: 5,
          costMats: { ward_coil: 1, beacon_ink: 1 },
          apply: (g) => { g.meta.legacy.safeRest = (g.meta.legacy.safeRest || 0) + 1; },
        },
        {
          key: "beacon_build",
          name: "Portable Relay (Build Beacons)",
          desc: "Carry the Beacon’s logic into the field. Make safety where there was none.",
          costEchoes: 7,
          costMats: { relay_parts: 2, ward_coil: 1 },
          apply: (g) => { g.meta.legacy.canBuildBeacons = true; },
        },
        {
          key: "void_bargain",
          name: "Void Bargain (Risk)",
          desc: "Gain power quickly. Pay later. The mountain always collects.",
          costEchoes: 3,
          costMats: { void_chit: 1 },
          apply: (g) => { g.meta.legacy.voidMarks = (g.meta.legacy.voidMarks || 0) + 1; },
        },
      ];

      // --- Random events (the “other 60%”) ---
      const AFFINITY_ATTACKS = [
        { key:"aff_firebrand", name:"Firebrand", kind:"action", desc:"A scorching strike. Higher damage, small self-burn risk.", tag:"affinity" },
        { key:"aff_frostbind", name:"Frostbind", kind:"action", desc:"A binding cold. Lower damage, reduces enemy attack.", tag:"affinity" },
        { key:"aff_thunderlink", name:"Thunderlink", kind:"action", desc:"A quick chain hit. Low damage but accurate.", tag:"affinity" },
        { key:"aff_stonecoil", name:"Stonecoil", kind:"action", desc:"A crushing ward. Damage + you Brace lightly.", tag:"affinity" },
        { key:"aff_voidbite", name:"Voidbite", kind:"action", desc:"A hungry cut. Big damage if you're low HP.", tag:"affinity" },
      ];

      const BORROWED_ABILITIES = [
        { key:"borrowed_duelist", name:"Borrowed Technique: Duelist", kind:"action", desc:"Once per combat: reroll an attack d20.", tag:"borrowed" },
        { key:"borrowed_warden", name:"Borrowed Technique: Warden", kind:"action", desc:"Once per combat: negate next enemy hit.", tag:"borrowed" },
        { key:"borrowed_invoker", name:"Borrowed Technique: Invoker", kind:"action", desc:"Once per combat: add +3 to a roll after seeing d20.", tag:"borrowed" },
      ];

      // =========================================================
      // GAME STATE
      // =========================================================
      function mkNewGame(seed = Date.now()) {
        const gameId = uid();
        const rngSeed = (seed ^ gameId.length) >>> 0;

        return {
          version: VERSION,
          gameId,
          rngSeed,

          // menu | setup_weapon | setup_style | setup_prologue | map | location | combat | beacon | dead
          mode: "menu",

          meta: {
            echoes: 0,
            bank: {
              scaled_fragment: 0,
              bright_glass: 0,
              ward_coil: 0,
              beacon_ink: 0,
              relay_parts: 0,
              void_chit: 0,
            },
            legacy: {
              startHP: 0,
              revealHints: 0,
              safeRest: 0,
              canBuildBeacons: false,
              voidMarks: 0,
            }
          },

          player: {
            weapon: null,
            style: null,
            element: null,
            crossStyle: null,

            baseStats: { might: 0, finesse: 0, wits: 0, will: 0 },
            runBuff: { might: 0, finesse: 0, wits: 0, will: 0 },  // events
            stats: { might: 0, finesse: 0, wits: 0, will: 0 },

            hpMax: 10,
            hp: 10,
            xp: 0,
            promoTier: 0,
            nextPromoAt: 4,
            title: "Unbound",

            // in-run materials (unbanked)
            pack: {
              scaled_fragment: 0,
              bright_glass: 0,
              ward_coil: 0,
              beacon_ink: 0,
              relay_parts: 0,
              void_chit: 0,
            },

            builtBeacons: [],
            extraSkills: [],

            // very rare “once per combat” flags for borrowed skills
            combatFlags: {},
          },

          run: {
            day: 1,
            region: "Ember March",
            revealedTier: 1,
            here: "l_beacon_gate",
            lastHere: null,

            inCombat: false,
            enemy: null,
            enemyHP: 0,

            log: [],
          },

          // transition overlay that summarizes outcomes
          transition: {
            open: false,
            title: "",
            subtitle: "",
            bullets: [],
            lore: "",
            nextMode: null,
          },

          ui: { toast: null, showPromotion: false }
        };
      }

      function pushLog(state, text, type="system") {
        const line = { id: uid(), t: Date.now(), type, text };
        state.run.log = [line, ...state.run.log].slice(0, 18);
      }

      function recalcPlayer(draft) {
        const w = WEAPONS.find((x) => x.key === draft.player.weapon);
        const bias = w?.bias || { might: 0, finesse: 0, wits: 0, will: 0 };
        draft.player.stats = computeStats(
          draft.player.baseStats,
          bias,
          draft.player.style,
          draft.player.element,
          draft.player.crossStyle,
          draft.player.runBuff
        );
        const hpBase = 10 + (draft.meta.legacy.startHP || 0);
        draft.player.hpMax = hpBase;
        draft.player.hp = clamp(draft.player.hp, 0, hpBase);
        draft.player.title = titleFromBuild(draft.player.weapon, draft.player.style, draft.player.element, draft.player.crossStyle);
      }

      function openTransition(draft, payload) {
        draft.transition.open = true;
        draft.transition.title = payload.title || "Outcome";
        draft.transition.subtitle = payload.subtitle || "";
        draft.transition.bullets = payload.bullets || [];
        draft.transition.lore = payload.lore || "";
        draft.transition.nextMode = payload.nextMode || null;
      }

      // =========================================================
      // UI ATOMS
      // =========================================================
      function Pill({ children }) {
        return (
          <span className="inline-flex items-center gap-1 rounded-full px-2 py-1 text-xs bg-white/10 border border-white/10">
            {children}
          </span>
        );
      }

      function Tooltip({ title, lines }) {
        return (
          <div className="tt">
            <div className="tt-box">
              <div className="text-xs font-semibold text-white/90">{title}</div>
              <div className="mt-1 space-y-1">
                {lines.map((l, i) => (
                  <div key={i} className="text-[11px] text-white/70 leading-snug">{l}</div>
                ))}
              </div>
            </div>
            <div className="tt-arrow"></div>
          </div>
        );
      }

      function Button({ children, onClick, variant = "primary", disabled, tooltip }) {
        const base =
          "rounded-2xl px-4 py-2 text-sm font-semibold border transition active:scale-[0.99] tracking-wide";
        const styles = {
          primary: "bg-white text-black border-white/20 hover:bg-white/90 disabled:opacity-50",
          ghost: "bg-white/5 text-white border-white/10 hover:bg-white/10 disabled:opacity-50",
          danger: "bg-red-500/15 text-red-200 border-red-500/30 hover:bg-red-500/20 disabled:opacity-50",
          gold: "bg-amber-300/15 text-amber-100 border-amber-300/25 hover:bg-amber-300/20 disabled:opacity-50",
        };

        return (
          <span className="tt-wrap">
            {tooltip ? <Tooltip title={tooltip.title} lines={tooltip.lines} /> : null}
            <button
              className={`${base} ${styles[variant]}`}
              onClick={onClick}
              disabled={disabled}
            >
              {children}
            </button>
          </span>
        );
      }

      function Divider() { return <div className="h-px bg-white/10 my-3" />; }

      function WhisperLog({ lines }) {
        const shown = [...lines].slice(0, 6).reverse();
        return (
          <div className="pointer-events-none absolute bottom-4 left-4 w-[min(520px,calc(100%-2rem))]">
            <div className="rounded-2xl ui-panel-soft px-3 py-2">
              <div className="ui-runic text-white/60">WHISPERS</div>
              <div className="mt-2 space-y-1">
                {shown.length === 0 ? (
                  <div className="text-xs text-white/50">…</div>
                ) : shown.map((l) => (
                  <div key={l.id} className="text-xs text-white/85 leading-snug">
                    <span className={
                      l.type === "roll" ? "text-amber-200" :
                      l.type === "lore" ? "text-indigo-200" :
                      l.type === "danger" ? "text-red-200" :
                      "text-white/85"
                    }>
                      {l.text}
                    </span>
                  </div>
                ))}
              </div>
            </div>
          </div>
        );
      }

      // =========================================================
      // PIXEL ART BACKDROP (generated "real" art)
      // =========================================================
      function PixelBackdrop({ mode, seed }) {
        const ref = useRef(null);

        useEffect(() => {
          const canvas = ref.current;
          if (!canvas) return;
          const ctx = canvas.getContext("2d", { alpha: true });

          let raf = 0;
          let t = 0;

          const resize = () => {
            const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
            canvas.width = Math.floor(canvas.clientWidth * dpr);
            canvas.height = Math.floor(canvas.clientHeight * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          };

          const rng = mulberry32((seed ^ 0xA11CE) >>> 0);

          // palettes by mode
          const palette = (() => {
            if (mode === "combat") return {
              sky: ["#07040A","#140815","#200A1B"],
              mist:"#1a0f1a",
              ridge:["#2a1021","#3b1226","#52152a"],
              glow:"#7c3aed"
            };
            if (mode === "beacon") return {
              sky: ["#04070A","#071019","#0A1A24"],
              mist:"#0b1822",
              ridge:["#0b2a2f","#0c3330","#13413b"],
              glow:"#f59e0b"
            };
            if (mode === "map") return {
              sky: ["#04050a","#070916","#0b0f22"],
              mist:"#0c1222",
              ridge:["#0f1a2a","#18203a","#222a4a"],
              glow:"#22c55e"
            };
            return {
              sky: ["#05050a","#0b0a14","#120c1f"],
              mist:"#0f0f18",
              ridge:["#171326","#22183a","#2d1e4d"],
              glow:"#38bdf8"
            };
          })();

          // pixel scale (low-res look)
          const PIX = 3; // bigger = chunkier

          function draw() {
            t += 0.006;
            const w = canvas.clientWidth;
            const h = canvas.clientHeight;

            // clear
            ctx.clearRect(0,0,w,h);

            // sky gradient (banded)
            const bands = 10;
            for (let i=0;i<bands;i++){
              const y0 = (i/bands)*h;
              const y1 = ((i+1)/bands)*h;
              const c = palette.sky[Math.floor((i/bands)*palette.sky.length)];
              ctx.fillStyle = c;
              ctx.fillRect(0, y0, w, (y1-y0)+1);
            }

            // stars
            const stars = mode === "combat" ? 30 : 60;
            ctx.fillStyle = "rgba(255,255,255,0.25)";
            for (let i=0;i<stars;i++){
              const x = (rng()*w + (Math.sin(t*0.7+i)*6)) % w;
              const y = (rng()*h*0.55);
              const s = (rng()<0.85) ? 1 : 2;
              ctx.fillRect(Math.floor(x), Math.floor(y), s, s);
            }

            // moon glow
            const gx = w*0.72, gy = h*0.22;
            const grd = ctx.createRadialGradient(gx,gy,0,gx,gy,Math.min(w,h)*0.35);
            grd.addColorStop(0, `${palette.glow}33`);
            grd.addColorStop(1, "rgba(0,0,0,0)");
            ctx.fillStyle = grd;
            ctx.fillRect(0,0,w,h);

            // mountain layers (pixel ridges)
            function ridgeLayer(baseY, amp, color, drift, jag) {
              ctx.fillStyle = color;
              ctx.beginPath();
              ctx.moveTo(0, h);
              ctx.lineTo(0, baseY);

              const step = PIX;
              for (let x=0;x<=w;x+=step){
                const n = Math.sin((x*0.01) + t*drift) * amp
                        + Math.sin((x*0.028) + t*(drift*0.6)) * (amp*0.35)
                        + (Math.sin((x*0.08)+t*0.4) * jag);
                const y = baseY + n;
                ctx.lineTo(x, y);
              }
              ctx.lineTo(w, h);
              ctx.closePath();
              ctx.fill();
            }

            ridgeLayer(h*0.62, 22, palette.ridge[0], 0.6, 3);
            ridgeLayer(h*0.72, 28, palette.ridge[1], 0.35, 4);
            ridgeLayer(h*0.82, 34, palette.ridge[2], 0.22, 5);

            // mist overlay
            const mg = ctx.createLinearGradient(0,h*0.35,0,h);
            mg.addColorStop(0, "rgba(0,0,0,0)");
            mg.addColorStop(0.55, palette.mist + "66");
            mg.addColorStop(1, "rgba(0,0,0,0.55)");
            ctx.fillStyle = mg;
            ctx.fillRect(0,0,w,h);

            raf = requestAnimationFrame(draw);
          }

          const onResize = () => { resize(); };
          window.addEventListener("resize", onResize);
          resize();
          draw();

          return () => {
            cancelAnimationFrame(raf);
            window.removeEventListener("resize", onResize);
          };
        }, [mode, seed]);

        return (
          <div className="absolute inset-0">
            <canvas ref={ref} className="w-full h-full block" />
            <div className="absolute inset-0 bg-[radial-gradient(70%_55%_at_50%_30%,rgba(0,0,0,0),rgba(0,0,0,0.55))]" />
          </div>
        );
      }

      // =========================================================
      // MAP ICONS (simple, gamey)
      // =========================================================
      function MapIcon({ kind, safe, active }) {
        const stroke = active ? "rgba(255,255,255,0.85)" : safe ? "rgba(34,197,94,0.65)" : "rgba(255,255,255,0.35)";
        const fill = safe ? "rgba(34,197,94,0.16)" : "rgba(124,58,237,0.14)";
        const inner = (() => {
          switch(kind){
            case "beacon": return "⌬";
            case "safe": return "⌂";
            case "ruin": return "⟐";
            case "pass": return "⟁";
            case "shrine": return "✦";
            default: return "•";
          }
        })();

        return (
          <g>
            <circle r="10" fill={fill} stroke={stroke} strokeWidth="2" />
            <text y="3.5" textAnchor="middle" fontSize="10" fill="rgba(255,255,255,0.78)" style={{fontFamily:"Press Start 2P"}}>
              {inner}
            </text>
          </g>
        );
      }

      // =========================================================
      // MAIN APP
      // =========================================================
      function DragonfallMountainExilePreview() {
        const [state, setState] = useState(() => mkNewGame());
        const toastTimer = useRef(null);

        const weaponObj = useMemo(() => WEAPONS.find((w) => w.key === state.player.weapon) || null, [state.player.weapon]);
        const styleObj = useMemo(
          () => WEAPONS.flatMap((w) => w.styles).find((s) => s.key === state.player.style) || null,
          [state.player.style]
        );
        const elementObj = useMemo(() => ELEMENTS.find((e) => e.key === state.player.element) || null, [state.player.element]);

        const here = useMemo(() => locById(state.run.here), [state.run.here]);
        const hereSafe = useMemo(() => isSafeLocation(here, state.player.builtBeacons), [here, state.player.builtBeacons]);

        const skills = useMemo(
          () => skillListForBuild(state.player.weapon, state.player.style, state.player.element, state.player.crossStyle, state.player.extraSkills),
          [state.player.weapon, state.player.style, state.player.element, state.player.crossStyle, state.player.extraSkills]
        );

        const showToast = (msg) => {
          setState((p) => ({ ...p, ui: { ...p.ui, toast: msg }}));
          if (toastTimer.current) clearTimeout(toastTimer.current);
          toastTimer.current = setTimeout(() => {
            setState((p) => ({ ...p, ui: { ...p.ui, toast: null }}));
          }, 1600);
        };

        const saveGame = () => {
          try { localStorage.setItem(SAVE_KEY, JSON.stringify(state)); showToast("Saved."); }
          catch { showToast("Save failed."); }
        };
        const loadGame = () => {
          try {
            const raw = localStorage.getItem(SAVE_KEY);
            if (!raw) return showToast("No save found.");
            const parsed = JSON.parse(raw);
            if (!parsed?.version) return showToast("Save invalid.");
            setState(parsed);
            showToast("Loaded.");
          } catch { showToast("Load failed."); }
        };
        const clearSave = () => { try { localStorage.removeItem(SAVE_KEY); showToast("Save cleared."); } catch { showToast("Could not clear."); } };

        const goMode = (mode) => setState((p) => ({ ...p, mode }));

        // ---------- Setup flow ----------
        const beginNewExile = () => {
          setState((prev) => {
            const fresh = mkNewGame(Date.now());
            fresh.meta = prev.meta; // keep beacon meta
            fresh.mode = "setup_weapon";
            recalcPlayer(fresh);
            pushLog(fresh, "The Beacon does not bless you. It only records you.", "lore");
            openTransition(fresh, {
              title: "New Exile",
              subtitle: "The light opens its ledger.",
              bullets: [
                `Beacon Echoes: ${fresh.meta.echoes}`,
                `Banked materials: ${Object.values(fresh.meta.bank).reduce((a,b)=>a+b,0)}`,
              ],
              lore: "You step forward anyway.",
              nextMode: "setup_weapon",
            });
            return fresh;
          });
        };

        const chooseWeapon = (weaponKey) => {
          setState((prev) => {
            const d = structuredClone(prev);
            d.player.weapon = weaponKey;
            recalcPlayer(d);
            d.mode = "setup_style";
            pushLog(d, `Armament chosen: ${weaponKey.toUpperCase()}.`);
            openTransition(d, {
              title: "Armament Bound",
              subtitle: WEAPONS.find(w=>w.key===weaponKey)?.tagline || "",
              bullets: [
                `Weapon: ${WEAPONS.find(w=>w.key===weaponKey)?.name}`,
                `You will specialize after your first blood and XP.`,
              ],
              lore: "A tool becomes a vow when the mountain is watching.",
              nextMode: "setup_style",
            });
            return d;
          });
        };

        const chooseStyle = (styleKey) => {
          setState((prev) => {
            const d = structuredClone(prev);
            d.player.style = styleKey;
            d.player.element = null;
            d.player.crossStyle = null;
            d.player.promoTier = 0;
            d.player.xp = 0;
            d.player.extraSkills = [];
            d.player.combatFlags = {};
            d.player.runBuff = { might:0, finesse:0, wits:0, will:0 };
            d.run.here = "l_beacon_gate";
            d.run.revealedTier = 1 + (d.meta.legacy.revealHints || 0);
            d.player.builtBeacons = [];
            recalcPlayer(d);
            d.mode = "setup_prologue";
            pushLog(d, `Discipline chosen: ${styleKey.toUpperCase()}.`);
            openTransition(d, {
              title: "Discipline Chosen",
              subtitle: `${WEAPONS.flatMap(w=>w.styles).find(s=>s.key===styleKey)?.name || "Style"}`,
              bullets: [
                `Title: ${d.player.title}`,
                `HP: ${d.player.hp}/${d.player.hpMax}`,
                `Specialization unlocks at ${d.player.nextPromoAt} XP.`,
              ],
              lore: "The mountain listens to the shape of your intent.",
              nextMode: "setup_prologue",
            });
            return d;
          });
        };

        const prologueContinue = () => {
          setState((prev) => {
            const d = structuredClone(prev);
            d.mode = "map";
            pushLog(d, `You step into the ${d.run.region}.`, "lore");
            openTransition(d, {
              title: "The Gate Opens",
              subtitle: "Choose a connected place. The mountain is a web, not a hallway.",
              bullets: [
                `Region: ${REGION_NAME[locById(d.run.here)?.tier || 1]}`,
                `Visible depth: ${clamp(1+(d.meta.legacy.revealHints||0),1,3)}`,
              ],
              lore: "Routes are rules. Break them if you can.",
              nextMode: "map",
            });
            return d;
          });
        };

        // ---------- Promotion ----------
        const choosePromotionElement = (elementKey) => {
          setState((prev) => {
            const d = structuredClone(prev);
            d.player.element = elementKey;
            d.player.crossStyle = null;
            d.player.promoTier = 1;
            d.ui.showPromotion = false;
            recalcPlayer(d);
            pushLog(d, `Specialization bound: ${elementKey.toUpperCase()}.`, "system");
            openTransition(d, {
              title: "Specialization Bound",
              subtitle: "An affinity takes the wheel.",
              bullets: [
                `New title: ${d.player.title}`,
                `Passive gained: Affinity`,
              ],
              lore: "You didn't pick power. Power picked you back.",
              nextMode: "location",
            });
            return d;
          });
        };
        const choosePromotionCross = (crossStyleKey) => {
          setState((prev) => {
            const d = structuredClone(prev);
            d.player.crossStyle = crossStyleKey;
            d.player.element = null;
            d.player.promoTier = 1;
            d.ui.showPromotion = false;
            recalcPlayer(d);
            pushLog(d, `Specialization taken: Cross-Training ${crossStyleKey.toUpperCase()}.`, "system");
            openTransition(d, {
              title: "Cross-Training Taken",
              subtitle: "You steal technique from another path.",
              bullets: [
                `New title: ${d.player.title}`,
                `Flexibility increased (Wits/Finesse).`,
              ],
              lore: "The mountain hates versatile prey. Good.",
              nextMode: "location",
            });
            return d;
          });
        };

        // ---------- Navigation ----------
        const canTravelTo = (fromId, toId) => neighborsOf(fromId).includes(toId);

        const travelTo = (toId) => {
          setState((prev) => {
            const d = structuredClone(prev);
            if (d.run.inCombat) return prev;

            const from = d.run.here;
            if (!canTravelTo(from, toId)) {
              pushLog(d, "That route is not passable from here.", "system");
              return d;
            }

            d.run.lastHere = from;
            d.run.here = toId;
            d.mode = "location";

            const L = locById(toId);
            pushLog(d, `⛰️ ${L.name}.`, "lore");
            pushLog(d, L.lore, "lore");

            openTransition(d, {
              title: "Travel",
              subtitle: `Arrived: ${L.name}`,
              bullets: [
                `Tier ${L.tier} • ${REGION_NAME[L.tier]}`,
                `Ground: ${isSafeLocation(L, d.player.builtBeacons) ? "Safe" : "Hostile"}`,
              ],
              lore: "Every step up the range is a quieter kind of violence.",
              nextMode: "location",
            });

            return d;
          });
        };

        // ---------- Odds: Explore combat vs event ----------
        function computeExploreOdds(draft) {
          const L = locById(draft.run.here);
          const safe = isSafeLocation(L, draft.player.builtBeacons);
          if (safe) return { combat: 0, event: 100, factors: ["Safe ground: combat disabled"] };

          // Base odds (what you asked for)
          let combat = 40;
          let event = 60;
          const factors = [];

          // Tier increases danger
          if (L.tier === 2) { combat += 8; event -= 8; factors.push("Tier 2: +8% combat"); }
          if (L.tier === 3) { combat += 14; event -= 14; factors.push("Tier 3: +14% combat"); }

          // Wits reduces combat odds a bit (you spot trouble first)
          const wits = draft.player.stats.wits || 0;
          const witsShift = clamp(wits * 2, -6, 10);
          combat -= witsShift;
          event += witsShift;
          if (witsShift !== 0) factors.push(`Wits ${fmtBonus(wits)}: ${witsShift>0?`+${witsShift}% event`:`${-witsShift}% event`}`);

          // Void marks (beacon upgrade) makes the mountain “louder”
          const vm = draft.meta.legacy.voidMarks || 0;
          if (vm > 0) {
            const bump = clamp(vm * 3, 0, 12);
            combat += bump; event -= bump;
            factors.push(`Void Marks ${vm}: +${bump}% combat`);
          }

          combat = clamp(Math.round(combat), 5, 90);
          event = 100 - combat;
          return { combat, event, factors };
        }

        // ---------- Random events ----------
        function runRandomEvent(draft) {
          const L = locById(draft.run.here);
          const rng = mulberry32(draft.rngSeed ^ draft.run.day ^ (L.tier*0xBEEF) ^ Date.now());

          // Weights by tier (deeper = rarer outcomes slightly more likely)
          const tierBoost = L.tier - 1;

          const roll = rng();

          // Uber rare: Borrowed ability (0.8% outer, 1.2% mid, 1.6% inner)
          const borrowedChance = 0.008 + tierBoost * 0.004;
          if (roll < borrowedChance) {
            const ab = BORROWED_ABILITIES[Math.floor(rng()*BORROWED_ABILITIES.length)];
            // only if not already owned
            if (!draft.player.extraSkills.some(s => s.key === ab.key)) {
              draft.player.extraSkills.push({ ...ab });
            }
            recalcPlayer(draft);
            return {
              title: "Random Event",
              subtitle: "You learn something you were never meant to learn.",
              bullets: [
                `Gained: ${ab.name}`,
                `This is a rare, once-per-combat trick (preview).`,
              ],
              lore: "A stranger’s discipline lodges under your skin like a splinter.",
            };
          }

          // Rare: Affinity attack (6% outer, 8% mid, 10% inner)
          const affChance = 0.06 + tierBoost * 0.02;
          if (roll < borrowedChance + affChance) {
            const atk = AFFINITY_ATTACKS[Math.floor(rng()*AFFINITY_ATTACKS.length)];
            if (!draft.player.extraSkills.some(s => s.key === atk.key)) {
              draft.player.extraSkills.push({ ...atk });
            }
            recalcPlayer(draft);
            return {
              title: "Random Event",
              subtitle: "The mountain lends you a mouthful of power.",
              bullets: [
                `Gained: ${atk.name} (combat action)`,
                `It’s not yours. It’s on loan.`,
              ],
              lore: "Lightning doesn't ask permission. Neither do you.",
            };
          }

          // Stat boon (20% outer, 24% mid, 28% inner)
          const boonChance = 0.20 + tierBoost * 0.04;
          if (roll < borrowedChance + affChance + boonChance) {
            const statKeys = ["might","finesse","wits","will"];
            const k = statKeys[Math.floor(rng()*statKeys.length)];
            draft.player.runBuff[k] += 1;
            recalcPlayer(draft);
            return {
              title: "Random Event",
              subtitle: "A brief, brutal lesson changes you.",
              bullets: [
                `Run buff: ${k.toUpperCase()} +1`,
                `This lasts for the current exile.`,
              ],
              lore: "You bleed in the right direction. The mountain approves.",
            };
          }

          // Otherwise: big resource find
          const drop = pickMaterialDrop(rng, L.tier);
          const amount = 2 + Math.floor(rng() * (3 + tierBoost)); // 2..(4+)
          draft.player.pack[drop.key] += amount;
          return {
            title: "Random Event",
            subtitle: "You find something useful. Quickly. Quietly.",
            bullets: [
              `Loot: ${drop.name} x${amount}`,
              `Pack grows heavier. Extraction becomes tempting.`,
            ],
            lore: "Sometimes the mountain drops coins to see if you bend over.",
          };
        }

        // ---------- Encounters ----------
        function startCombat(draft, forced = false) {
          const L = locById(draft.run.here);
          const rng = mulberry32(draft.rngSeed ^ draft.run.day ^ 0xDEAD ^ Date.now());
          const enemy = pickEnemyByTier(rng, L.tier);

          draft.run.inCombat = true;
          draft.run.enemy = { ...enemy };
          draft.run.enemyHP = enemy.hp;
          draft.mode = "combat";

          // reset per-combat borrowed flags
          draft.player.combatFlags = {};

          pushLog(draft, `⚔️ ${enemy.name} emerges.`, "danger");
          if (forced) pushLog(draft, "You stirred the wrong kind of silence.", "danger");
        }

        // ---------- Location actions (hostile set) ----------
        const explore = () => {
          setState((prev) => {
            const d = structuredClone(prev);
            if (d.mode !== "location" || d.run.inCombat) return prev;

            const L = locById(d.run.here);
            const safe = isSafeLocation(L, d.player.builtBeacons);

            const odds = computeExploreOdds(d);
            const rng = mulberry32(d.rngSeed ^ d.run.day ^ 0xC0DE ^ Date.now());
            const roll = Math.floor(rng()*100) + 1;

            if (safe) {
              // Safe explore -> always event (non-combat)
              const outcome = runRandomEvent(d);
              openTransition(d, { ...outcome, nextMode: "location" });
              pushLog(d, "You explore safely.", "system");
              return d;
            }

            if (roll <= odds.combat) {
              startCombat(d, false);
              openTransition(d, {
                title: "Explore",
                subtitle: "You found trouble first.",
                bullets: [
                  `Outcome: Combat`,
                  `Tier ${L.tier} enemy engaged.`,
                ],
                lore: "The mountain doesn’t spawn monsters. It reveals them.",
                nextMode: "combat",
              });
              return d;
            } else {
              const outcome = runRandomEvent(d);
              openTransition(d, { ...outcome, nextMode: "location" });
              pushLog(d, "You explore and find something… else.", "lore");
              return d;
            }
          });
        };

        const stirUpNoGood = () => {
          setState((prev) => {
            const d = structuredClone(prev);
            if (d.mode !== "location" || d.run.inCombat) return prev;
            const L = locById(d.run.here);
            const safe = isSafeLocation(L, d.player.builtBeacons);
            if (safe) {
              openTransition(d, {
                title: "Stir Up No Good",
                subtitle: "Not here.",
                bullets: ["Safe ground refuses to answer your provocation."],
                lore: "Even chaos respects wards.",
                nextMode: "location",
              });
              return d;
            }
            startCombat(d, true);
            openTransition(d, {
              title: "Provocation",
              subtitle: "You rang the bell.",
              bullets: ["Outcome: Forced combat", `Tier ${L.tier} enemy engaged.`],
              lore: "Some doors open inward.",
              nextMode: "combat",
            });
            return d;
          });
        };

        const rest = () => {
          setState((prev) => {
            const d = structuredClone(prev);
            if (d.mode !== "location") return prev;

            const L = locById(d.run.here);
            const safe = isSafeLocation(L, d.player.builtBeacons);

            const baseHeal = 2;
            const bonus = safe ? (1 + (d.meta.legacy.safeRest || 0)) : 0;
            const heal = baseHeal + bonus;
            const before = d.player.hp;

            d.player.hp = clamp(d.player.hp + heal, 0, d.player.hpMax);
            d.run.day += 1;

            openTransition(d, {
              title: "Rest",
              subtitle: safe ? "Safe ground. No monsters." : "Open ground. The mountain hears you.",
              bullets: [
                `HP: ${before} → ${d.player.hp} (+${heal})`,
                `Day advances: ${d.run.day}`,
                safe ? "No combat can trigger from this rest." : "Exploration becomes riskier over time (preview)."
              ],
              lore: safe ? "For a moment, your breath belongs only to you." : "Sleep is a contract you sign with your eyes closed.",
              nextMode: "location",
            });

            pushLog(d, safe ? `You rest safely (+${heal} HP).` : `You rest in the open (+${heal} HP).`, "system");
            return d;
          });
        };

        const buildBeacon = () => {
          setState((prev) => {
            const d = structuredClone(prev);
            if (d.mode !== "location") return prev;

            if (!d.meta.legacy.canBuildBeacons) {
              openTransition(d, {
                title: "Build Beacon",
                subtitle: "Knowledge missing.",
                bullets: ["Requires Beacon upgrade: Portable Relay."],
                lore: "You can’t carve safety from stone until you learn the language of light.",
                nextMode: "location",
              });
              return d;
            }

            const L = locById(d.run.here);
            if (isSafeLocation(L, d.player.builtBeacons)) {
              openTransition(d, {
                title: "Build Beacon",
                subtitle: "Already warded.",
                bullets: ["This location is already safe."],
                lore: "You don't stack prayers on top of prayers.",
                nextMode: "location",
              });
              return d;
            }

            if (d.player.pack.relay_parts < 1 || d.player.pack.ward_coil < 1) {
              openTransition(d, {
                title: "Build Beacon",
                subtitle: "Missing materials.",
                bullets: ["Need: Relay Parts x1", "Need: Ward Coil x1"],
                lore: "A beacon is not a torch. It's a machine with a memory.",
                nextMode: "location",
              });
              return d;
            }

            d.player.pack.relay_parts -= 1;
            d.player.pack.ward_coil -= 1;
            d.player.builtBeacons.push(L.id);

            openTransition(d, {
              title: "Field Beacon",
              subtitle: "Safety forged.",
              bullets: [
                `${L.name} is now a safe place.`,
                "Rest becomes monster-free here.",
                "Extraction is now possible here.",
              ],
              lore: "Light bites into the dark and refuses to let go.",
              nextMode: "location",
            });

            pushLog(d, `${L.name} becomes safe.`, "system");
            return d;
          });
        };

        const extractToBank = () => {
          setState((prev) => {
            const d = structuredClone(prev);
            if (d.mode !== "location") return prev;

            const L = locById(d.run.here);
            const safe = isSafeLocation(L, d.player.builtBeacons);

            if (!safe) {
              openTransition(d, {
                title: "Extraction",
                subtitle: "Unsafe.",
                bullets: ["Extraction requires safety: Beacon, refuge, or built ward."],
                lore: "You can’t pack evidence while knives are out.",
                nextMode: "location",
              });
              return d;
            }

            const beforeTotal = Object.values(d.player.pack).reduce((a,b)=>a+b,0);
            let moved = 0;
            for (const k of Object.keys(d.player.pack)) {
              const amt = d.player.pack[k] || 0;
              if (amt > 0) {
                d.meta.bank[k] = (d.meta.bank[k] || 0) + amt;
                d.player.pack[k] = 0;
                moved += amt;
              }
            }

            openTransition(d, {
              title: "Extraction Complete",
              subtitle: "The Beacon accepts proof.",
              bullets: [
                `Banked: ${moved} item(s)`,
                `Pack emptied: ${beforeTotal} → 0`,
                `Bank total: ${Object.values(d.meta.bank).reduce((a,b)=>a+b,0)}`,
              ],
              lore: "What you extract becomes permanent. What you carry stays negotiable.",
              nextMode: "location",
            });

            pushLog(d, `Extraction complete. Banked ${moved}.`, "system");
            return d;
          });
        };

        // ---------- Combat ----------
        const takeDamage = (draft, amount, reason) => {
          draft.player.hp = clamp(draft.player.hp - amount, 0, draft.player.hpMax);
          pushLog(draft, `🩸 You take ${amount} damage (${reason}).`, "danger");
          if (draft.player.hp <= 0) {
            draft.mode = "dead";
            const L = locById(draft.run.here);
            const depthEcho = (L?.tier || 1) + Math.floor(draft.player.xp / 2);
            const carryPenalty = Object.values(draft.player.pack).reduce((a,b)=>a+b,0);
            const echoes = Math.max(2, depthEcho) + Math.floor(carryPenalty / 3);
            draft.meta.echoes += echoes;

            // lose unbanked materials
            for (const k of Object.keys(draft.player.pack)) draft.player.pack[k] = 0;

            openTransition(draft, {
              title: "You Fall",
              subtitle: "The mountain keeps the rest.",
              bullets: [
                `Echoes gained: +${echoes}`,
                "Unextracted pack: LOST",
                `Bank remains: ${Object.values(draft.meta.bank).reduce((a,b)=>a+b,0)} mats`,
              ],
              lore: "The Beacon does not mourn. It records.",
              nextMode: "dead",
            });

            pushLog(draft, `☠️ You fall. +${echoes} Echoes at the Beacon.`, "danger");
          }
        };

        const enemyTurn = (draft, context = "combat") => {
          const enemy = draft.run.enemy;
          if (!enemy) return;

          const rng = mulberry32(draft.rngSeed ^ draft.run.day ^ 0x1111 ^ draft.run.enemyHP);
          const defMod = computeDefenseMod(draft.player.stats, draft.player.style);
          const defendActive = !!draft.run._defendActive;
          const braceBonus = defendActive ? 2 : 0;

          const check = rollCheck(rng, `${enemy.name} attacks`, defMod + braceBonus, enemy.attackDR);
          pushLog(draft, `🎲 ${check.label}: d20 ${check.d20} ${fmtBonus(check.statBonus)} = ${check.total} vs DR ${check.dr} → ${check.success ? "HIT" : "MISS"}`, "roll");

          if (check.success) {
            let dmg = rollDamage(rng, enemy.dmg[0], enemy.dmg[1]);
            if (defendActive) dmg = Math.max(0, dmg - 1 - (draft.player.element === "earth" ? 1 : 0));
            takeDamage(draft, dmg, context);
          } else {
            pushLog(draft, "You avoid the blow.", "system");
          }
          draft.run._defendActive = false;
        };

        const endCombatWin = (draft, enemyName) => {
          const L = locById(draft.run.here);
          const rng = mulberry32(draft.rngSeed ^ draft.run.day ^ 0xbeef ^ Date.now());

          const drop = pickMaterialDrop(rng, L.tier);
          draft.player.pack[drop.key] += 1;

          const xpGain = L.tier;
          draft.player.xp += xpGain;

          draft.run.inCombat = false;
          draft.run.enemy = null;
          draft.run.enemyHP = 0;
          draft.mode = "location";

          // Promotion unlock
          let promoText = null;
          if (draft.player.promoTier === 0 && draft.player.xp >= draft.player.nextPromoAt) {
            draft.ui.showPromotion = true;
            promoText = "Specialization unlocked!";
          }

          openTransition(draft, {
            title: "Combat Resolved",
            subtitle: `Defeated: ${enemyName}`,
            bullets: [
              `XP gained: +${xpGain} (Total XP: ${draft.player.xp})`,
              `Loot: ${drop.name} x1`,
              promoText ? promoText : "No further change.",
            ].filter(Boolean),
            lore: "Violence is the mountain’s native tongue. You’re getting fluent.",
            nextMode: "location",
          });

          pushLog(draft, `Victory. +${xpGain} XP. Loot: ${drop.name} x1.`, "system");
        };

        const combatAction = (key) => {
          setState((prev) => {
            const d = structuredClone(prev);
            if (d.mode !== "combat" || !d.run.inCombat || !d.run.enemy) return prev;

            const enemy = d.run.enemy;
            const rng = mulberry32(d.rngSeed ^ d.run.day ^ 0x2222 ^ Date.now());

            const atkMod = computeAttackMod(d.player.stats, d.player.weapon);
            const defMod = computeDefenseMod(d.player.stats, d.player.style);

            const doAttack = (label, bonus, dmgMin, dmgMax, onMiss) => {
              const check = rollCheck(rng, label, atkMod + bonus, enemy.dr);
              pushLog(d, `🎲 ${check.label}: d20 ${check.d20} ${fmtBonus(check.statBonus)} = ${check.total} vs DR ${check.dr} → ${check.success ? "SUCCESS" : "FAIL"}`, "roll");

              if (check.success) {
                let dmg = rollDamage(rng, dmgMin, dmgMax);
                if (check.d20 === 20) {
                  dmg += 1;
                  if (d.player.element === "fire") dmg += 1;
                  pushLog(d, "✦ Critical impact.", "system");
                }
                d.run.enemyHP = Math.max(0, d.run.enemyHP - dmg);
                pushLog(d, `Enemy takes ${dmg} damage.`, "system");
                if (d.run.enemyHP <= 0) { endCombatWin(d, enemy.name); return; }
              } else {
                if (onMiss) onMiss();
              }
              if (d.mode !== "dead") enemyTurn(d, "combat");
            };

            // Base actions
            if (key === "attack") { doAttack("You attack", 0, 1, 3); return d; }

            if (key === "defend") {
              d.run._defendActive = true;
              pushLog(d, `You Brace (Defense ${fmtBonus(defMod)}).`, "system");
              enemyTurn(d, "brace");
              return d;
            }

            if (key === "maneuver") {
              const check = rollCheck(rng, "You Maneuver", d.player.stats.wits + d.player.stats.finesse, DR.standard);
              pushLog(d, `🎲 ${check.label}: d20 ${check.d20} ${fmtBonus(check.statBonus)} = ${check.total} vs DR ${check.dr} → ${check.success ? "SUCCESS" : "FAIL"}`, "roll");
              if (check.success) pushLog(d, "You gain Advantage (preview flavor).", "system");
              else takeDamage(d, 1, "misstep");
              if (d.mode !== "dead") enemyTurn(d, "counter");
              return d;
            }

            // Style specials
            if (key === "aim") { doAttack("Aimed Shot", 2, 1, 4); return d; }
            if (key === "dash") {
              const check = rollCheck(rng, "Dash Shot", atkMod + 1, enemy.dr);
              pushLog(d, `🎲 ${check.label}: d20 ${check.d20} ${fmtBonus(check.statBonus)} = ${check.total} vs DR ${check.dr} → ${check.success ? "SUCCESS" : "FAIL"}`, "roll");
              if (check.success) {
                const dmg = rollDamage(rng, 1, 3);
                d.run.enemyHP = Math.max(0, d.run.enemyHP - dmg);
                pushLog(d, `Enemy takes ${dmg} damage.`, "system");
                if (d.run.enemyHP <= 0) { endCombatWin(d, enemy.name); return d; }
                pushLog(d, "You slip out of reach. No retaliation.", "system");
                return d;
              }
              enemyTurn(d, "dash-fail");
              return d;
            }
            if (key === "snare") {
              pushLog(d, "You set a Snare. Enemy Attack DR +2 once.", "system");
              const old = enemy.attackDR; enemy.attackDR = old + 2;
              enemyTurn(d, "snare");
              enemy.attackDR = old;
              return d;
            }
            if (key === "bolt") { doAttack("Arc Bolt", 1, 1, 5); return d; }
            if (key === "hex") {
              const old = enemy.dr; enemy.dr = Math.max(8, enemy.dr - 2);
              pushLog(d, "Hex: Enemy DR −2 this turn.", "system");
              doAttack("Hexed Strike", 0, 1, 2);
              enemy.dr = old;
              return d;
            }
            if (key === "focus") { doAttack("Focused Cast", 2, 1, 4); return d; }
            if (key === "riposte") { doAttack("Shield-Check", 0, 1, 2); return d; }
            if (key === "bleed") { doAttack("Open Vein", 0, 2, 4, () => takeDamage(d, 1, "overextension")); return d; }
            if (key === "lunge") { doAttack("Lunge", 1, 2, 5, () => takeDamage(d, 2, "exposed")); return d; }

            // Event-granted: Affinity attacks
            if (key === "aff_firebrand") { doAttack("Firebrand", 1, 2, 5, () => takeDamage(d, 1, "burn-back")); return d; }
            if (key === "aff_frostbind") {
              const old = enemy.attackDR; enemy.attackDR = old + 2;
              doAttack("Frostbind", 0, 1, 3);
              enemy.attackDR = old;
              return d;
            }
            if (key === "aff_thunderlink") { doAttack("Thunderlink", 2, 1, 2); return d; }
            if (key === "aff_stonecoil") { d.run._defendActive = true; doAttack("Stonecoil", 0, 1, 4); return d; }
            if (key === "aff_voidbite") {
              const bonus = (d.player.hp <= Math.ceil(d.player.hpMax*0.4)) ? 3 : 0;
              doAttack("Voidbite", bonus, 2, 6);
              return d;
            }

            // Uber rare borrowed abilities (preview: once per combat)
            if (key === "borrowed_duelist") {
              if (d.player.combatFlags.borrowed_duelist) { pushLog(d, "That technique is spent for this combat.", "system"); enemyTurn(d, "wasted"); return d; }
              d.player.combatFlags.borrowed_duelist = true;
              pushLog(d, "Borrowed Duelist: your next attack rerolls on failure (preview).", "system");
              // Implement: make one boosted attack with a reroll
              const attempt = () => {
                const check = rollCheck(rng, "Borrowed Duelist Strike", atkMod + 1, enemy.dr);
                pushLog(d, `🎲 ${check.label}: d20 ${check.d20} ${fmtBonus(check.statBonus)} = ${check.total} vs DR ${check.dr} → ${check.success ? "SUCCESS" : "FAIL"}`, "roll");
                return check;
              };
              let c = attempt();
              if (!c.success) {
                pushLog(d, "Reroll!", "system");
                c = attempt();
              }
              if (c.success) {
                const dmg = rollDamage(rng, 2, 5);
                d.run.enemyHP = Math.max(0, d.run.enemyHP - dmg);
                pushLog(d, `Enemy takes ${dmg} damage.`, "system");
                if (d.run.enemyHP <= 0) { endCombatWin(d, enemy.name); return d; }
              }
              enemyTurn(d, "borrowed");
              return d;
            }

            if (key === "borrowed_warden") {
              if (d.player.combatFlags.borrowed_warden) { pushLog(d, "That technique is spent for this combat.", "system"); enemyTurn(d, "wasted"); return d; }
              d.player.combatFlags.borrowed_warden = true;
              d.player.combatFlags.negateNextHit = true;
              pushLog(d, "Borrowed Warden: negate the next enemy hit (preview).", "system");
              // Enemy still attacks, but hit can be negated in enemyTurn:
              const enemyTurnPatched = () => {
                const e = d.run.enemy;
                const r = mulberry32(d.rngSeed ^ d.run.day ^ 0x3333 ^ d.run.enemyHP);
                const def = computeDefenseMod(d.player.stats, d.player.style);
                const check = rollCheck(r, `${e.name} attacks`, def, e.attackDR);
                pushLog(d, `🎲 ${check.label}: d20 ${check.d20} ${fmtBonus(check.statBonus)} = ${check.total} vs DR ${check.dr} → ${check.success ? "HIT" : "MISS"}`, "roll");
                if (check.success) {
                  if (d.player.combatFlags.negateNextHit) {
                    d.player.combatFlags.negateNextHit = false;
                    pushLog(d, "The ward flares. The hit is negated.", "system");
                    return;
                  }
                  const dmg = rollDamage(r, e.dmg[0], e.dmg[1]);
                  takeDamage(d, dmg, "combat");
                } else pushLog(d, "You avoid the blow.", "system");
              };
              enemyTurnPatched();
              return d;
            }

            if (key === "borrowed_invoker") {
              if (d.player.combatFlags.borrowed_invoker) { pushLog(d, "That technique is spent for this combat.", "system"); enemyTurn(d, "wasted"); return d; }
              d.player.combatFlags.borrowed_invoker = true;
              // Implement: a single empowered roll
              const check = rollCheck(rng, "Borrowed Invoker", atkMod, enemy.dr);
              pushLog(d, `🎲 ${check.label}: d20 ${check.d20} ${fmtBonus(check.statBonus)} = ${check.total} vs DR ${check.dr}`, "roll");
              const boosted = { ...check, total: check.total + 3, success: (check.total + 3) >= check.dr };
              pushLog(d, `✦ After-seeing boost: +3 → ${boosted.total} → ${boosted.success ? "SUCCESS" : "FAIL"}`, "system");
              if (boosted.success) {
                const dmg = rollDamage(rng, 3, 6);
                d.run.enemyHP = Math.max(0, d.run.enemyHP - dmg);
                pushLog(d, `Enemy takes ${dmg} damage.`, "system");
                if (d.run.enemyHP <= 0) { endCombatWin(d, enemy.name); return d; }
              }
              enemyTurn(d, "borrowed");
              return d;
            }

            return d;
          });
        };

        // ---------- Beacon ----------
        const enterBeacon = () => {
          setState((prev) => {
            const d = structuredClone(prev);
            d.mode = "beacon";
            openTransition(d, {
              title: "The Beacon",
              subtitle: "Between runs, the ledger opens.",
              bullets: [
                `Echoes: ${d.meta.echoes}`,
                `Banked mats: ${Object.values(d.meta.bank).reduce((a,b)=>a+b,0)}`,
              ],
              lore: "A quiet room where upgrades feel like prophecy.",
              nextMode: "beacon",
            });
            return d;
          });
        };

        const buyUpgrade = (up) => {
          setState((prev) => {
            const d = structuredClone(prev);
            if (d.meta.echoes < up.costEchoes) { showToast("Not enough Echoes."); return d; }
            for (const [k,amt] of Object.entries(up.costMats || {})) {
              if ((d.meta.bank[k] || 0) < amt) { showToast("Missing mats."); return d; }
            }
            d.meta.echoes -= up.costEchoes;
            for (const [k,amt] of Object.entries(up.costMats || {})) d.meta.bank[k] -= amt;
            up.apply(d);
            openTransition(d, {
              title: "Beacon Upgraded",
              subtitle: up.name,
              bullets: [
                `Echoes spent: ${up.costEchoes}`,
                ...Object.entries(up.costMats||{}).map(([k,amt]) => `${mat(k)?.name || k} x${amt}`),
              ],
              lore: "The Beacon rewrites you with patient hands.",
              nextMode: "beacon",
            });
            return d;
          });
        };

        // ---------- Transition close ----------
        const closeTransition = () => {
          setState((prev) => {
            const d = structuredClone(prev);
            d.transition.open = false;
            if (d.transition.nextMode) d.mode = d.transition.nextMode;
            d.transition.nextMode = null;
            return d;
          });
        };

        // ---------- Map reveal ----------
        const revealTier = useMemo(() => clamp(1 + (state.meta.legacy.revealHints || 0), 1, 3), [state.meta.legacy.revealHints]);
        const reachable = useMemo(() => new Set(neighborsOf(state.run.here)), [state.run.here]);

        // initial logs
        useEffect(() => {
          setState((prev) => {
            const d = structuredClone(prev);
            if (d.run.log.length === 0) {
              pushLog(d, "Preview build. Save/Load works. Transitions summarize outcomes.", "system");
              pushLog(d, "The mountain is a map now—routes are real.", "lore");
            }
            return d;
          });
        }, []);

        // =========================================================
        // UI: HUD / Screens
        // =========================================================
        const classPrompt = useMemo(() => {
          if (!state.player.weapon || !state.player.style) return "";
          const base = `${WEAPONS.find(w => w.key === state.player.weapon)?.name || "Weapon"} ${WEAPONS.flatMap(w => w.styles).find(s => s.key === state.player.style)?.name || "Style"}`;
          if (state.player.promoTier === 0) return `You are ${base}. Unspecialized.`;
          const spec = state.player.element
            ? `Bound to ${ELEMENTS.find(e => e.key === state.player.element)?.name || "Element"}.`
            : state.player.crossStyle
              ? `Cross-trained in ${WEAPONS.flatMap(w => w.styles).find(s => s.key === state.player.crossStyle)?.name || "Cross"}.`
              : "";
          return `${state.player.title}. ${spec}`;
        }, [state.player.weapon, state.player.style, state.player.promoTier, state.player.element, state.player.crossStyle, state.player.title]);

        const TopHUD = () => (
          <div className="absolute top-0 left-0 right-0 z-30">
            <div className="mx-auto max-w-6xl px-4 md:px-6 pt-4">
              <div className="ui-panel rounded-3xl px-4 md:px-6 py-4">
                <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
                  <div className="select-none">
                    <div className="ui-runic text-white/60">
                      DRAGONFALL • MOUNTAIN EXILE • v{VERSION}
                    </div>
                    <div className="ui-title text-2xl md:text-3xl font-bold mt-1">
                      {state.mode === "menu" ? "The Beacon" :
                       state.mode === "beacon" ? "Beacon Upgrades" :
                       state.mode === "map" ? "Mountain Map" :
                       state.mode === "combat" ? "Combat" :
                       state.mode === "location" ? "Location" :
                       state.mode.startsWith("setup") ? "Preparation" :
                       state.mode === "dead" ? "Fallen" :
                       "Dragonfall"}
                    </div>
                    {state.mode !== "menu" ? (
                      <div className="text-sm text-white/70 mt-2">
                        <span className="text-white/85 font-semibold">{classPrompt}</span>
                        <span className="text-white/40"> • </span>
                        <span className="text-white/70">{REGION_NAME[here?.tier || 1]}</span>
                      </div>
                    ) : (
                      <div className="text-sm text-white/70 mt-2">
                        A ledger of climbs. Echoes and materials shape your next exile.
                      </div>
                    )}
                  </div>

                  <div className="flex flex-wrap gap-2">
                    <Button onClick={saveGame} variant="ghost">Save</Button>
                    <Button onClick={loadGame} variant="ghost">Load</Button>
                    <Button onClick={clearSave} variant="ghost">Clear</Button>
                    <Button onClick={beginNewExile} variant="danger">New Exile</Button>
                    <Button onClick={enterBeacon} variant="gold">Beacon</Button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );

        const RightHUD = () => (
          <div className="absolute top-[124px] right-0 z-20">
            <div className="pr-4 md:pr-6">
              <div className="rounded-3xl ui-panel-soft px-4 py-4 w-[min(360px,calc(100vw-1rem))]">
                <div className="flex flex-wrap gap-2">
                  <Pill>HP {state.player.hp}/{state.player.hpMax}</Pill>
                  <Pill>XP {state.player.xp}</Pill>
                  <Pill>Echoes {state.meta.echoes}</Pill>
                </div>
                <div className="mt-2 text-xs text-white/60">
                  Banked mats fuel Beacon upgrades. Unextracted pack is lost on death.
                </div>
                {state.player.runBuff && (state.player.runBuff.might||state.player.runBuff.finesse||state.player.runBuff.wits||state.player.runBuff.will) ? (
                  <div className="mt-3 text-xs text-white/70">
                    Run Buffs: {["might","finesse","wits","will"].map(k => (state.player.runBuff[k] ? `${k.toUpperCase()} ${fmtBonus(state.player.runBuff[k])}` : null)).filter(Boolean).join(" • ")}
                  </div>
                ) : null}
              </div>
            </div>
          </div>
        );

        const MenuScreen = () => (
          <div className="relative z-10 min-h-screen flex items-center justify-center">
            <div className="w-full max-w-5xl px-4 md:px-6 pt-32 pb-10">
              <div className="ui-panel rounded-3xl p-6 md:p-8">
                <div className="ui-title text-4xl md:text-5xl font-bold">DRAGONFALL</div>
                <div className="text-white/75 mt-3 leading-relaxed">
                  You don’t sell loot. You extract proof. Materials become Beacon buffs.
                  The mountain is a web of locations—move only along real connections.
                </div>
                <Divider />
                <div className="flex flex-wrap gap-3">
                  <Button onClick={beginNewExile}>New Exile</Button>
                  <Button variant="ghost" onClick={() => {
                    if (state.player.weapon && state.player.style) goMode("map");
                    else beginNewExile();
                  }}>
                    Continue
                  </Button>
                  <Button variant="gold" onClick={enterBeacon}>Beacon</Button>
                </div>

                <div className="mt-6 rounded-3xl ui-panel-soft p-4">
                  <div className="ui-runic text-white/60">BEACON HOLDINGS</div>
                  <div className="mt-3 flex flex-wrap gap-2">
                    {Object.keys(state.meta.bank).map((k) => (
                      <Pill key={k}>{mat(k)?.name || k}: {state.meta.bank[k] || 0}</Pill>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          </div>
        );

        const SetupWeaponScreen = () => (
          <div className="relative z-10 min-h-screen flex items-center justify-center">
            <div className="w-full max-w-6xl px-4 md:px-6 pt-32 pb-10">
              <div className="ui-panel rounded-3xl p-6 md:p-8">
                <div className="ui-runic text-white/60">PREPARATION</div>
                <div className="ui-title text-3xl md:text-4xl font-bold mt-2">Choose your armament</div>
                <div className="text-white/70 mt-2">Only the first set of choices. Specialization comes after XP.</div>
                <Divider />
                <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                  {WEAPONS.map((w) => (
                    <button
                      key={w.key}
                      onClick={() => chooseWeapon(w.key)}
                      className="rounded-3xl p-5 border text-left transition hover:bg-white/5 border-white/10 bg-white/5"
                    >
                      <div className="ui-title text-2xl font-bold">{w.name}</div>
                      <div className="text-sm text-white/70 mt-1">{w.tagline}</div>
                      <div className="text-xs text-white/60 mt-3">
                        Bias: Might {fmtBonus(w.bias.might)} • Finesse {fmtBonus(w.bias.finesse)} • Wits {fmtBonus(w.bias.wits)} • Will {fmtBonus(w.bias.will)}
                      </div>
                    </button>
                  ))}
                </div>
              </div>
            </div>
          </div>
        );

        const SetupStyleScreen = () => (
          <div className="relative z-10 min-h-screen flex items-center justify-center">
            <div className="w-full max-w-6xl px-4 md:px-6 pt-32 pb-10">
              <div className="ui-panel rounded-3xl p-6 md:p-8">
                <div className="ui-runic text-white/60">PREPARATION</div>
                <div className="ui-title text-3xl md:text-4xl font-bold mt-2">Choose your discipline</div>
                <div className="text-white/70 mt-2">Your first real identity. The mountain will test it.</div>
                <Divider />
                <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                  {weaponObj?.styles.map((s) => (
                    <button
                      key={s.key}
                      onClick={() => chooseStyle(s.key)}
                      className="rounded-3xl p-5 border text-left transition hover:bg-white/5 border-white/10 bg-white/5"
                    >
                      <div className="ui-title text-2xl font-bold">{s.name}</div>
                      <div className="text-sm text-white/70 mt-1">{s.desc}</div>
                    </button>
                  ))}
                </div>
              </div>
            </div>
          </div>
        );

        const SetupPrologueScreen = () => (
          <div className="relative z-10 min-h-screen flex items-center justify-center">
            <div className="w-full max-w-5xl px-4 md:px-6 pt-32 pb-10">
              <div className="ui-panel rounded-3xl p-6 md:p-8">
                <div className="ui-runic text-white/60">PROLOGUE</div>
                <div className="ui-title text-3xl md:text-4xl font-bold mt-2">The gate remembers your footsteps.</div>
                <div className="text-white/75 mt-4 leading-relaxed">
                  You begin at Beacon Gate. You’ll fight a little. Gain XP. Then the mountain offers a specialization.
                </div>
                <Divider />
                <div className="flex flex-wrap gap-2">
                  <Pill>Title: {state.player.title}</Pill>
                  <Pill>HP {state.player.hp}/{state.player.hpMax}</Pill>
                  <Pill>Promo at {state.player.nextPromoAt} XP</Pill>
                </div>
                <Divider />
                <Button onClick={prologueContinue}>Open the Map</Button>
              </div>
            </div>
          </div>
        );

        const MapScreen = () => (
          <div className="relative z-10 min-h-screen">
            <div className="mx-auto max-w-6xl px-4 md:px-6 pt-32 pb-10">
              <div className="grid grid-cols-1 lg:grid-cols-12 gap-4">
                <div className="lg:col-span-8">
                  <div className="ui-panel rounded-3xl overflow-hidden relative h-[72vh]">
                    <svg viewBox="0 0 100 100" className="w-full h-full">
                      {/* subtle connection lines */}
                      {CONNECTIONS.map(([a,b], i) => {
                        const A = locById(a), B = locById(b);
                        if (!A || !B) return null;
                        if (A.tier > revealTier || B.tier > revealTier) return null;
                        const near = (a === state.run.here || b === state.run.here);
                        return (
                          <line
                            key={i}
                            x1={A.x} y1={A.y}
                            x2={B.x} y2={B.y}
                            stroke={near ? "rgba(255,255,255,0.22)" : "rgba(255,255,255,0.10)"}
                            strokeWidth={near ? 1.8 : 1.2}
                            opacity={near ? 1 : 0.85}
                          />
                        );
                      })}

                      {/* location icons */}
                      {LOCATIONS.map((L) => {
                        if (L.tier > revealTier) return null;
                        const isHere = L.id === state.run.here;
                        const isReach = reachable.has(L.id);
                        const safe = isSafeLocation(L, state.player.builtBeacons);

                        return (
                          <g
                            key={L.id}
                            transform={`translate(${L.x} ${L.y})`}
                            className={isReach ? "cursor-pointer" : ""}
                            onClick={() => { if (isReach && !isHere) travelTo(L.id); }}
                            opacity={isHere ? 1 : (isReach ? 0.95 : 0.55)}
                          >
                            <MapIcon kind={L.kind} safe={safe} active={isHere} />
                            <text x="14" y="4" fontSize="3.2" fill="rgba(255,255,255,0.72)">
                              {L.name}
                            </text>
                          </g>
                        );
                      })}
                    </svg>

                    <div className="absolute top-3 left-3 right-3 flex items-start justify-between gap-3">
                      <div className="rounded-2xl ui-panel-soft px-3 py-2">
                        <div className="ui-runic text-white/60">MAP</div>
                        <div className="text-sm text-white/85 mt-2">
                          You are at <span className="font-semibold">{here?.name}</span>.
                        </div>
                        <div className="text-xs text-white/60 mt-1">
                          Visible depth: <span className="text-white/85 font-semibold">{revealTier}</span> • Reachable icons glow.
                        </div>
                      </div>

                      <div className="rounded-2xl ui-panel-soft px-3 py-2">
                        <div className="ui-runic text-white/60">LEGEND</div>
                        <div className="text-xs text-white/70 mt-2 space-y-1">
                          <div>⌬ Beacon • ⌂ Safe • ⟐ Ruin</div>
                          <div>⟁ Pass • ✦ Shrine • • Wild</div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="lg:col-span-4">
                  <div className="ui-panel rounded-3xl p-5 h-[72vh] overflow-auto">
                    <div className="ui-runic text-white/60">ADJACENT PLACES</div>
                    <div className="ui-title text-2xl font-bold mt-2">Choose where to go</div>
                    <div className="text-sm text-white/70 mt-2">
                      Travel is only between connected locations.
                    </div>
                    <Divider />
                    <div className="space-y-2">
                      {neighborsOf(state.run.here)
                        .map(id => locById(id))
                        .filter(Boolean)
                        .filter(L => L.tier <= revealTier)
                        .map((L) => {
                          const safe = isSafeLocation(L, state.player.builtBeacons);
                          return (
                            <button
                              key={L.id}
                              onClick={() => travelTo(L.id)}
                              className="w-full text-left rounded-2xl border border-white/10 bg-white/5 hover:bg-white/10 transition p-4"
                            >
                              <div className="flex items-center justify-between gap-3">
                                <div className="font-semibold">{L.name}</div>
                                <div className="text-xs text-white/60">Tier {L.tier}</div>
                              </div>
                              <div className="text-xs text-white/60 mt-1">
                                {safe ? "Safe" : "Hostile"} • {L.kind} • {REGION_NAME[L.tier]}
                              </div>
                            </button>
                          );
                        })}
                    </div>

                    <Divider />
                    <div className="text-sm font-semibold">Pack (unextracted)</div>
                    <div className="mt-2 flex flex-wrap gap-2">
                      {Object.keys(state.player.pack).map((k) => (
                        <Pill key={k}>{mat(k)?.name || k}: {state.player.pack[k] || 0}</Pill>
                      ))}
                    </div>

                    <Divider />
                    <div className="flex flex-wrap gap-2">
                      <Button variant="ghost" onClick={() => goMode("location")}>Return</Button>
                      <Button variant="gold" onClick={enterBeacon}>Beacon</Button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );

        const LocationScreen = () => {
          const L = here;
          const safe = hereSafe;
          const odds = computeExploreOdds(state);

          return (
            <div className="relative z-10 min-h-screen">
              <div className="mx-auto max-w-6xl px-4 md:px-6 pt-32 pb-10">
                <div className="grid grid-cols-1 lg:grid-cols-12 gap-4">
                  <div className="lg:col-span-8">
                    <div className="ui-panel rounded-3xl p-6 md:p-8 h-[72vh] overflow-auto">
                      <div className="ui-runic text-white/60">{REGION_NAME[L?.tier || 1].toUpperCase()}</div>
                      <div className="ui-title text-4xl font-bold mt-2">{L?.name}</div>
                      <div className="text-white/75 mt-4 leading-relaxed">{L?.lore}</div>

                      <Divider />

                      <div className="flex flex-wrap gap-2 items-center">
                        <Pill>{safe ? "Safe ground" : "Hostile ground"}</Pill>
                        <Pill>Tier {L?.tier}</Pill>
                        <Pill>Kind: {L?.kind}</Pill>
                      </div>

                      <Divider />

                      <div className="ui-runic text-white/60">ACTIONS</div>
                      <div className="mt-3 flex flex-wrap gap-3">
                        <Button
                          onClick={explore}
                          disabled={state.run.inCombat}
                          tooltip={{
                            title: safe ? "Explore (Safe)" : "Explore (Odds)",
                            lines: safe
                              ? ["Safe ground: combat disabled.", "You will trigger a non-combat event."]
                              : [
                                  `Combat: ${odds.combat}% • Random Event: ${odds.event}%`,
                                  "Factors:",
                                  ...odds.factors.map(f => `• ${f}`)
                                ],
                          }}
                        >
                          Explore
                        </Button>

                        <Button
                          onClick={stirUpNoGood}
                          variant="ghost"
                          disabled={state.run.inCombat}
                          tooltip={{
                            title: "Stir Up No Good",
                            lines: safe
                              ? ["Safe ground refuses to answer provocation."]
                              : ["Forces combat in this area.", "No odds. No mercy."],
                          }}
                        >
                          Stir Up No Good
                        </Button>

                        <Button onClick={rest} variant="ghost" disabled={state.run.inCombat}>
                          Rest
                        </Button>

                        <Button onClick={extractToBank} variant="gold" disabled={!safe || state.run.inCombat}
                          tooltip={{
                            title: "Extract",
                            lines: safe
                              ? ["Banks your pack materials permanently.", "Only possible on safe ground."]
                              : ["Requires safety: Beacon, refuge, or built ward."],
                          }}
                        >
                          Extract
                        </Button>

                        <Button onClick={() => goMode("map")} variant="ghost" disabled={state.run.inCombat}>
                          Open Map
                        </Button>

                        <Button
                          onClick={buildBeacon}
                          variant="ghost"
                          disabled={state.run.inCombat}
                          tooltip={{
                            title: "Build Beacon",
                            lines: [
                              "Requires Beacon upgrade: Portable Relay",
                              "Cost (from pack): Relay Parts x1, Ward Coil x1",
                              "Turns this location into safe ground.",
                            ],
                          }}
                        >
                          Build Beacon
                        </Button>
                      </div>

                      <Divider />
                      <div className="text-sm font-semibold">Pack (unextracted)</div>
                      <div className="mt-2 flex flex-wrap gap-2">
                        {Object.keys(state.player.pack).map((k) => (
                          <Pill key={k}>{mat(k)?.name || k}: {state.player.pack[k] || 0}</Pill>
                        ))}
                      </div>
                    </div>
                  </div>

                  <div className="lg:col-span-4">
                    <div className="ui-panel rounded-3xl p-5 h-[72vh] overflow-auto">
                      <div className="ui-runic text-white/60">CHARACTER</div>
                      <div className="ui-title text-2xl font-bold mt-2">{state.player.title}</div>
                      <div className="text-sm text-white/70 mt-2">
                        Weapon: {weaponObj?.name || "—"} • Style: {styleObj?.name || "—"}
                      </div>
                      <div className="text-sm text-white/70 mt-1">
                        {elementObj ? `Affinity: ${elementObj.name}` : state.player.crossStyle ? `Cross: ${WEAPONS.flatMap(w=>w.styles).find(s=>s.key===state.player.crossStyle)?.name}` : "Unspecialized"}
                      </div>

                      <Divider />
                      <div className="grid grid-cols-2 gap-3">
                        {["might","finesse","wits","will"].map((k) => (
                          <div key={k} className="rounded-2xl border border-white/10 bg-white/5 p-3">
                            <div className="ui-runic text-white/60">{k.toUpperCase()}</div>
                            <div className="text-lg font-semibold mt-2">{fmtBonus(state.player.stats[k])}</div>
                          </div>
                        ))}
                      </div>

                      <Divider />
                      <div className="text-sm font-semibold">Known Techniques</div>
                      <div className="text-xs text-white/60 mt-1">Event-granted skills appear here.</div>
                      <div className="mt-3 space-y-2">
                        {skills.filter(s => s.tag === "affinity" || s.tag === "borrowed").slice(0, 6).map((s) => (
                          <div key={s.key} className="rounded-2xl border border-white/10 bg-white/5 p-3">
                            <div className="flex items-center justify-between">
                              <div className="font-semibold">{s.name}</div>
                              <div className="text-[10px] text-white/50 uppercase">{s.tag}</div>
                            </div>
                            <div className="text-xs text-white/60 mt-1">{s.desc}</div>
                          </div>
                        ))}
                        {skills.filter(s => s.tag === "affinity" || s.tag === "borrowed").length === 0 ? (
                          <div className="text-sm text-white/50">None yet.</div>
                        ) : null}
                      </div>

                      <Divider />
                      <div className="flex flex-wrap gap-2">
                        <Button variant="ghost" onClick={() => goMode("map")}>Map</Button>
                        <Button variant="gold" onClick={enterBeacon}>Beacon</Button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          );
        };

        const CombatScreen = () => {
          const enemy = state.run.enemy;
          return (
            <div className="relative z-10 min-h-screen">
              <div className="mx-auto max-w-6xl px-4 md:px-6 pt-32 pb-10">
                <div className="ui-panel rounded-3xl p-6 md:p-8 h-[76vh] overflow-hidden relative">
                  <div className="flex flex-col md:flex-row md:items-start md:justify-between gap-6">
                    <div className="max-w-2xl">
                      <div className="ui-runic text-white/60">COMBAT</div>
                      <div className="ui-title text-4xl font-bold mt-2">{enemy?.name}</div>
                      <div className="text-white/75 mt-4 leading-relaxed">{enemy?.desc}</div>

                      <Divider />

                      <div className="flex flex-wrap gap-2">
                        <Pill>Enemy HP {state.run.enemyHP}/{enemy?.hp}</Pill>
                        <Pill>Enemy DR {enemy?.dr}</Pill>
                        <Pill>Attack DR {enemy?.attackDR}</Pill>
                        <Pill>Tier {enemy?.tier}</Pill>
                      </div>

                      <Divider />

                      <div className="ui-runic text-white/60">ACTIONS</div>
                      <div className="mt-3 flex flex-wrap gap-3">
                        {/* core */}
                        <Button onClick={() => combatAction("attack")}>Attack</Button>
                        <Button variant="ghost" onClick={() => combatAction("defend")}>Brace</Button>
                        <Button variant="ghost" onClick={() => combatAction("maneuver")}>Maneuver</Button>

                        {/* style + event actions */}
                        {skills
                          .filter((s) => s.kind === "action" && !["attack","defend","maneuver"].includes(s.key))
                          .slice(0, 8)
                          .map((s) => (
                            <Button
                              key={s.key}
                              variant="ghost"
                              onClick={() => combatAction(s.key)}
                              tooltip={{
                                title: s.name,
                                lines: [s.desc, s.tag ? `Tag: ${s.tag}` : ""].filter(Boolean),
                              }}
                            >
                              {s.name}
                            </Button>
                          ))}
                      </div>

                      <div className="mt-6 text-xs text-white/60">
                        After combat, you’ll get a transition summary: enemy, XP, loot.
                      </div>
                    </div>

                    <div className="w-full md:w-[340px] shrink-0">
                      <div className="rounded-3xl ui-panel-soft p-5">
                        <div className="ui-runic text-white/60">YOU</div>
                        <div className="ui-title text-2xl font-bold mt-2">{state.player.title}</div>
                        <div className="text-sm text-white/80 mt-2">HP {state.player.hp}/{state.player.hpMax}</div>

                        <Divider />

                        <div className="grid grid-cols-2 gap-3">
                          {["might","finesse","wits","will"].map((k) => (
                            <div key={k} className="rounded-2xl border border-white/10 bg-black/20 p-3">
                              <div className="ui-runic text-white/60">{k.toUpperCase()}</div>
                              <div className="text-lg font-semibold mt-2">{fmtBonus(state.player.stats[k])}</div>
                            </div>
                          ))}
                        </div>

                        <Divider />
                        <div className="text-xs text-white/60">
                          Pack is at risk. Extraction only on safe ground.
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="pointer-events-none absolute inset-0 bg-[radial-gradient(70%_60%_at_50%_40%,rgba(0,0,0,0),rgba(0,0,0,0.55))]" />
                </div>
              </div>
            </div>
          );
        };

        const DeadScreen = () => (
          <div className="relative z-10 min-h-screen flex items-center justify-center">
            <div className="w-full max-w-5xl px-4 md:px-6 pt-32 pb-10">
              <div className="ui-panel rounded-3xl p-6 md:p-8">
                <div className="ui-runic text-white/60">FALLEN</div>
                <div className="ui-title text-4xl font-bold mt-2">The mountain keeps the rest.</div>
                <div className="text-white/75 mt-4 leading-relaxed">
                  Unextracted materials are gone. The Beacon awards Echoes. That is all.
                </div>
                <Divider />
                <div className="flex flex-wrap gap-2">
                  <Pill>Echoes {state.meta.echoes}</Pill>
                  <Pill>Banked mats {Object.values(state.meta.bank).reduce((a,b)=>a+b,0)}</Pill>
                  <Pill>XP this exile {state.player.xp}</Pill>
                </div>
                <Divider />
                <div className="flex flex-wrap gap-3">
                  <Button variant="gold" onClick={enterBeacon}>Enter Beacon</Button>
                  <Button variant="ghost" onClick={() => goMode("menu")}>Menu</Button>
                </div>
              </div>
            </div>
          </div>
        );

        const BeaconScreen = () => (
          <div className="relative z-10 min-h-screen">
            <div className="mx-auto max-w-6xl px-4 md:px-6 pt-32 pb-10">
              <div className="grid grid-cols-1 lg:grid-cols-12 gap-4">
                <div className="lg:col-span-7">
                  <div className="ui-panel rounded-3xl p-6 md:p-8 h-[76vh] overflow-auto">
                    <div className="ui-runic text-white/60">THE BEACON</div>
                    <div className="ui-title text-4xl font-bold mt-2">Upgrades</div>
                    <div className="text-white/75 mt-4 leading-relaxed">
                      Echoes are memory. Materials are evidence. Bind them into power.
                    </div>

                    <Divider />
                    <div className="flex flex-wrap gap-2">
                      <Pill>Echoes: {state.meta.echoes}</Pill>
                      <Pill>Reveal: {state.meta.legacy.revealHints || 0}</Pill>
                      <Pill>Start HP: {state.meta.legacy.startHP || 0}</Pill>
                      <Pill>Safe Rest: {state.meta.legacy.safeRest || 0}</Pill>
                      <Pill>Build Beacons: {state.meta.legacy.canBuildBeacons ? "Yes" : "No"}</Pill>
                      <Pill>Void Marks: {state.meta.legacy.voidMarks || 0}</Pill>
                    </div>

                    <Divider />
                    <div className="space-y-3">
                      {BEACON_UPGRADES.map((up) => {
                        const canAffordEcho = state.meta.echoes >= up.costEchoes;
                        const canAffordMats = Object.entries(up.costMats || {}).every(([k,amt]) => (state.meta.bank[k] || 0) >= amt);
                        const ok = canAffordEcho && canAffordMats;

                        return (
                          <div key={up.key} className="rounded-3xl ui-panel-soft p-5">
                            <div className="flex items-start justify-between gap-4">
                              <div>
                                <div className="ui-title text-2xl font-bold">{up.name}</div>
                                <div className="text-sm text-white/70 mt-2">{up.desc}</div>
                                <div className="text-xs text-white/60 mt-3">
                                  Cost: <span className="text-white/85 font-semibold">{up.costEchoes}</span> Echoes
                                  {Object.keys(up.costMats || {}).length ? (
                                    <>
                                      {" "}•{" "}
                                      {Object.entries(up.costMats).map(([k,amt]) => (
                                        <span key={k} className="mr-2">
                                          {mat(k)?.name || k} <span className="text-white/85 font-semibold">x{amt}</span>
                                        </span>
                                      ))}
                                    </>
                                  ) : null}
                                </div>
                              </div>
                              <div>
                                <Button variant={ok ? "primary" : "ghost"} disabled={!ok} onClick={() => buyUpgrade(up)}>
                                  Bind
                                </Button>
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </div>

                <div className="lg:col-span-5">
                  <div className="ui-panel rounded-3xl p-6 h-[76vh] overflow-auto">
                    <div className="ui-runic text-white/60">BANK</div>
                    <div className="ui-title text-3xl font-bold mt-2">Extracted Materials</div>
                    <Divider />
                    <div className="space-y-2">
                      {Object.keys(state.meta.bank).map((k) => (
                        <div key={k} className="rounded-2xl ui-panel-soft p-4">
                          <div className="flex items-center justify-between">
                            <div className="font-semibold">{mat(k)?.name || k}</div>
                            <div className="text-sm text-white/90 font-semibold">{state.meta.bank[k] || 0}</div>
                          </div>
                          <div className="text-xs text-white/60 mt-2">{mat(k)?.desc || "—"}</div>
                        </div>
                      ))}
                    </div>

                    <Divider />
                    <div className="flex flex-wrap gap-2">
                      <Button variant="ghost" onClick={() => goMode("menu")}>Menu</Button>
                      <Button onClick={beginNewExile}>New Exile</Button>
                    </div>

                    <Divider />
                    <div className="text-xs text-white/60 leading-relaxed">
                      Next wave later: actual imported asset packs (sprites/UI textures) + sound + event chainlets.
                      For now, the pixel backdrop is generated art, so it’s “real” and lightweight.
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );

        // Promotion Modal
        const PromotionModal = () => (
          <div className="fixed inset-0 bg-black/70 flex items-center justify-center p-4 z-50">
            <div className="max-w-2xl w-full ui-panel rounded-3xl p-5 wipe">
              <div className="flex items-start justify-between gap-3">
                <div>
                  <div className="ui-title text-2xl font-bold">Specialization Unlocked</div>
                  <div className="text-sm text-white/70 mt-2">
                    Choose one: bind an Element, or cross-train a Style.
                  </div>
                </div>
                <Button variant="ghost" onClick={() => setState((p) => ({ ...p, ui: { ...p.ui, showPromotion: false } }))}>
                  Later
                </Button>
              </div>
              <Divider />
              <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                <div className="rounded-3xl ui-panel-soft p-4">
                  <div className="font-semibold">Bind an Element</div>
                  <div className="text-sm text-white/70 mt-1">Sharper identity. Titles evolve.</div>
                  <div className="grid grid-cols-2 gap-2 mt-3">
                    {ELEMENTS.map((e) => (
                      <Button key={e.key} variant="ghost" onClick={() => choosePromotionElement(e.key)}>
                        {e.name}
                      </Button>
                    ))}
                  </div>
                </div>

                <div className="rounded-3xl ui-panel-soft p-4">
                  <div className="font-semibold">Cross-Train a Style</div>
                  <div className="text-sm text-white/70 mt-1">More options. Less raw power.</div>
                  <div className="grid grid-cols-2 gap-2 mt-3">
                    {WEAPONS.flatMap((w) => w.styles)
                      .filter((s) => s.key !== state.player.style)
                      .slice(0, 8)
                      .map((s) => (
                        <Button key={s.key} variant="ghost" onClick={() => choosePromotionCross(s.key)}>
                          {s.name}
                        </Button>
                      ))}
                  </div>
                  <div className="text-xs text-white/50 mt-2">(Preview: curated list for now.)</div>
                </div>
              </div>
            </div>
          </div>
        );

        // Transition Overlay
        const TransitionOverlay = () => (
          <div className="fixed inset-0 bg-black/70 flex items-center justify-center p-4 z-50">
            <div className="max-w-xl w-full ui-panel rounded-3xl p-5 wipe">
              <div className="ui-runic text-white/60">TRANSITION</div>
              <div className="ui-title text-3xl font-bold mt-2">{state.transition.title}</div>
              {state.transition.subtitle ? <div className="text-white/70 mt-2">{state.transition.subtitle}</div> : null}
              <Divider />
              <div className="space-y-2">
                {state.transition.bullets.map((b, i) => (
                  <div key={i} className="text-sm text-white/80">• {b}</div>
                ))}
              </div>
              {state.transition.lore ? (
                <>
                  <Divider />
                  <div className="text-sm text-indigo-200/90 leading-relaxed">
                    {state.transition.lore}
                  </div>
                </>
              ) : null}
              <Divider />
              <div className="flex justify-end gap-2">
                <Button variant="primary" onClick={closeTransition}>Continue</Button>
              </div>
            </div>
          </div>
        );

        // Screen router
        const screen =
          state.mode === "menu" ? <MenuScreen/> :
          state.mode === "setup_weapon" ? <SetupWeaponScreen/> :
          state.mode === "setup_style" ? <SetupStyleScreen/> :
          state.mode === "setup_prologue" ? <SetupPrologueScreen/> :
          state.mode === "map" ? <MapScreen/> :
          state.mode === "location" ? <LocationScreen/> :
          state.mode === "combat" ? <CombatScreen/> :
          state.mode === "beacon" ? <BeaconScreen/> :
          state.mode === "dead" ? <DeadScreen/> :
          <MenuScreen/>;

        return (
          <div className="relative min-h-screen text-white overflow-hidden">
            {/* Pixel backdrop counts as "real art" and is mode-themed */}
            <PixelBackdrop mode={state.mode} seed={state.rngSeed} />

            <TopHUD />
            {state.mode !== "menu" ? <RightHUD /> : null}

            {screen}

            {/* Small event log */}
            {state.mode !== "menu" ? <WhisperLog lines={state.run.log} /> : null}

            {/* Transition overlay */}
            {state.transition.open ? <TransitionOverlay /> : null}

            {/* Promotion Modal */}
            {state.ui.showPromotion ? <PromotionModal /> : null}

            {/* Toast */}
            {state.ui.toast ? (
              <div className="fixed bottom-4 left-1/2 -translate-x-1/2 z-50">
                <div className="rounded-full bg-white text-black px-4 py-2 text-sm shadow-xl">{state.ui.toast}</div>
              </div>
            ) : null}
          </div>
        );
      }

      ReactDOM.render(
        React.createElement(DragonfallMountainExilePreview),
        document.getElementById("root")
      );
    </script>
  </body>
</html>
